<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[计算机网络]]></title>
    <url>%2F2019%2F09%2F10%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[OSI参考模型OSI参考模型结构包括以下7层：物理层，数据链路层，网络层，传输层，会话层，表示层和应用层。 物理层实现比特流的透明传输，为数据链路层提供数据传输服务物理层的数据传输单位是比特（bit） 数据链路层数据链路层在物理层提供比特流传输的基础上，通过建立数据链路连接，采用差错控制与流量控制方法，使有差错的物理线路变成无差错的数据链路。数据链路层的数据传输单位是帧。 网络层网络层通过路由选择算法为分组通过通信子网选择适当的传输路径，实现流量控制，拥塞控制与网络互联的功能。网络层的数据传输功能是分组。 传输层传输层为分布在不同地理位置计算机的进程通信提供可靠的端-端连接与数据传输服务。传输层的数据传输单元是报文。TCP/IP参考模型TCP/IP起源目前TCP/IP已经成为公认的Internet工业标准与事实上的Internet协议标准。目前使用的TCP/IP是版本4，即IPv4。TCP/IP参考模型的层次主机-网络层与OSI参考模型的数据链路层和物理层对应。TCP/IP协议对主机-网络层并没有规定具体的协议。互联网络层（网络层）(IP)使用的是IP协议，IP是一种不可控，无连接的数据报传输服务协议，它提供的是一种“尽力而为”的服务。传输层（UDP，TCP）传输层定义两种不同的协议，传输控制层（Transport Control Protocol,TCP）与用户数据报协议（User Datagram Protocol，UDP）。TCP是一种可靠的，面向连接，面向字节流的传输层协议。TCP提供比较完善的流量控制与拥塞控制功能。UDP是一种不可靠的，无连接的传输层协议。TCP（Transmisson Control Protocol）TCP 是面向连接的（需要先建立连接）；每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是一对一；TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。UDP（User Datagram Protocol）UDP 是无连接的；UDP 是尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态；UDP 是面向报文的；UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如直播，实时视频会议等）；UDP 支持一对一、一对多、多对一和多对多的交互通信；UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。 1231.单工数据传输只支持数据在一个方向上传输2.半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信；3.全双工数据通信允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。 应用层()应用层包括各种标准的网络应用协议，并且总有不断有新的协议加入。TCP/IP应用层基本的协议主要有： 远程登录协议（TELNET） 文件传输协议（File Transfer Protocol,FTP） 超文本传输协议（HTTP） 域名服务协议（DNS）IPv4协议的基本内容IP协议的主要特点 IP协议是一种无连接，不可靠的分组传送服务的协议。 无连接意味着IP协议并不维护IP分组发送后的任何状态信息。每个分组的传输过程是相互独立的。 不可靠意味着IP协议不能保证每个IP分组都能够正确地，不丢失和顺序地到达目的主机。 IP协议是点-点的网络层通信协议。网络层需要在Internet中为通信的两个主机之间寻找一条路径，而这条路径通常是由多个路由器，点-点链路组成。因此，IP协议是针对源主机-路由器，路由器-路由器，路由器-目的主机之间的数据传输的点-点线路的网络层通信协议。IP地址的点分十进制的表示方法“网络号-主机号”的两级IP地址结构。IPv4的地址长度为32位，用点分十进制表示。通常采用x.x.x.x的格式来表示，每个x为8位，每个X的值为0~255. 标准IP地址的分类 A类地址A类地址网络号的第一位为0，其余的7位可以分配，0 网络号（7位），主机号（24位）。A类地址共分为大小相同的128（2^7 = 128）,每一块的netID不同。 B类地址B类地址的前两位为10，其余14位可以分配，可分配的网络号为2^14。B类地址的主机号长度为16位。10 网络号（14） 主机号（16位） C类地址C类地址的前三位为110，其余的21位可以分配。主机号为8位。 D类地址前4位为1110 E类地址前5位为11110。特殊地址形式特殊的IP地址包括以下四种类型 直接广播地址在A类，B类与C类IP地址中，如果主机号是全1，那么这个地址为直接广播地址，路由器将这个分组以广播方式发送给特定网络的所有主机。 受限广播地址32位网络号与主机号为全1的IP地址（255.255.255.255）为受限广播地址。它是用来将一个分组以广播方式发送给本网络中的所有主机。 “这个网络上的特定主机”地址在A类，B类，C类IP地址中，如果网络号是全0（如0.0.0.25），该地址是这个网络上的特定主机地址。划分子网的三级地址结构子网划分的基本思想是：借用主机号的一部分作为子网的子网号，划分出更多的子网IP地址。IPv6地址IPv6的128地址按每16位划分为一个位段，每个位段被转换为一个4位的十六进制数，并用冒号隔开，这种表示法称为“冒号十六进制表示法”。x:x:x:x:x:x:x:x零压缩法双冒号在一个地址中只能出现一次，如何确定双冒号之间被压缩0的位数？可以数一下地址中还有多少个位段，然后用8减去这个数，再将结果乘以16。例如，在地址FF02:3::5中有三个位段，可以根据公式计算：(8-3)*16=80,则 ::表示有80位的二进制数字0被压缩。2]]></content>
      <categories>
        <category>复习</category>
      </categories>
      <tags>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务]]></title>
    <url>%2F2019%2F09%2F10%2F%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[事务的概念事务就是一组原子性的sql,或者说一个独立的工作单元。事务就是说，要么MySql引擎会全部执行这一组SQL语句，要么全部都不执行。 事务的ACIDAtomicity，原子性：一个事务必须保证其中的操作要么全部执行，要么全部回滚，不可能存在只执行了一部分这种情况出现。Consistency，一致性：事务必须保证从一种一致性状态转换为另一种一致性状态。Isolation,隔离性：事务互相隔离，在一个事务未执行完毕时，通常会保证其他Session无法看到这个事务的执行结果。Durability，持久性：事务一旦commit，则数据就会保存下来，即使提交完之后系统崩溃，数据也不会丢失。 隔离级别以下，我们来详细来说一说隔离性我们都知道，事务控制的太严格，程序在并发訪问的情况下，会减少程序的性能。所以。人们总是想让事务为性能做出让步。那么就分出了四种隔离级别：为未提交读、提交读、可重复度读、序列化。可是。因为隔离界别限制的程度不同，那么就会产生脏读、不可反复读、幻读的情况。 脏读：脏读就是指当一个事务正在訪问数据，而且对数据进行了改动，而这样的改动还没有提交到数据库中，这时。另外一个事务也訪问这个数据，然后使用了这个数据。 不可反复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时。另外一个事务也訪问该同一数据。那么，在第一个事务中的两次读数据之间，因为第二个事务的改动，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可反复读。比如。一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改。原始读取不可反复。假设仅仅有在作者所有完毕编写后编辑人员才干够读取文档，则能够避免该问题。 幻读:是指当事务不是独立运行时发生的一种现象，比如第一个事务对一个表中的数据进行了改动，这样的改动涉及到表中的所有数据行。同一时候。第二个事务也改动这个表中的数据。这样的改动是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有改动的数据行，就好象发生了幻觉一样。比如。一个编辑人员更改作者提交的文档。但当生产部门将其更改内容合并到该文档的主复本时，发现作者已将未编辑的新材料加入到该文档中。事务并发下隔离级别的场景 未提交读公司发工资了，领导把5000元打到singo的账号上，但是该事务并未提交，而singo正好去查看账户，发现工资已经到账，是5000元整。很高兴。但是不幸的是。领导发现发给singo的工资金额不正确。是2000元。于是迅速回滚了事务，改动金额后，将事务提交，最后singo实际的工资仅仅有2000元，singo空欢喜一场。出现上述情况，即我们所说的脏读。两个并发的事务，“事务A：领导给singo发工资”、“事务B：singo查询工资账户”，事务B读取了事务A尚未提交的数据。当隔离级别设置为Readuncommitted时，就可能出现脏读，怎样避免脏读。请看下一个隔离级别。 读提交singo拿着工资卡去消费。系统读取到卡里确实有2000元。而此时她的老婆也正好在网上转账，把singo工资卡的2000元转到还有一账户，并在singo之前提交了事务，当singo扣款时，系统检查到singo的工资卡已经没有钱，扣款失败，singo十分纳闷，明明卡里有钱，为何……出现上述情况，即我们所说的不可反复读。两个并发的事务，“事务A：singo消费”、“事务B：singo的老婆网上转账”。事务A事先读取了数据。事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。当隔离级别设置为Readcommitted时，避免了脏读。可是可能会造成不可反复读。大多数数据库的默认级别就是Readcommitted。比方Sql Server , Oracle。怎样解决不可反复读这一问题。请看下一个隔离级别。 反复读当隔离级别设置为Repeatableread时。能够避免不可反复读。当singo拿着工资卡去消费时。一旦系统開始读取工资卡信息（即事务開始）。singo的老婆就不可能对该记录进行改动，也就是singo的老婆不能在此时转账。尽管Repeatableread避免了不可反复读，但还有可能出现幻读。singo的老婆工作在银行部门。她时常通过银行内部系统查看singo的信用卡消费记录。有一天，她正在查询到singo当月信用卡的总消费金额（select sum(amount) from transaction where month =本月）为80元。而singo此时正好在外面胡吃海塞后在收银台买单。消费1000元，即新增了一条1000元的消费记录（insert transaction… ）。并提交了事务。随后singo的老婆将singo当月信用卡消费的明细打印到A4纸上。却发现消费总额为1080元，singo的老婆非常诧异，以为出现了幻觉。幻读就这样产生了。注：Mysql的默认隔离级别就是Repeatableread。 序列化Serializable是最高的事务隔离级别。同一时候代价也花费最高，性能非常低，一般非常少使用，在该级别下，事务顺序运行，不仅能够避免脏读、不可反复读，还避免了幻像读。mysql开启事务默认情况下，mysql每执行一条sql语句都是一条事务，自动提交。如果一条事务有多条sql语句需要执行，要开启一个新的事务12345678910开启事务start transaction....结束事务commit/rollback或 通过AutoCommit设置事务开启或关闭show variables like "autocommit"set autocommit = 0; //0表示AutoCommit关闭set autocommit = 1； //1表示AutoCommit开启 在执行SQL语句之前，先执行start transaction，这就开启了一个事务（事务的起点），然后可以去执行多条SQL语句，最后要结束事务，commit表示提交，即事务中的多条SQL语句所作出的影响会持久到数据库中，或者rollback，表示回滚到事务的起点，之前做的所有操作都被撤销了。 jdbc 开启事务默认自动提交事务，若要手动提交，则关闭事务。在JDBC中处理事务，都是通过Connection完成的。同一事务中所有的操作，都在使用同一个Connection对象。1234con.setAutoCommit(false) 表示开启事务。...(进行多条sql)commit（）：提交结束事务。rollback（）：回滚结束事务。 附上jdbc代码练习12345678910111213141516171819202122232425262728public static void main(String[] args) throws ClassNotFoundException &#123; Connection conn= null; String driver = "com.mysql.jdbc.Driver"; //时区问题，serverTimezone=UTC String url = "jdbc:mysql://localhost:3306/czt?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC"; String name = "root"; String password = "666666"; //先获取链接驱动 Class.forName(driver); String sql =null; try &#123; //通过driverManager获取链接 conn = DriverManager.getConnection(url, name, password); if (conn != null )&#123; System.out.println("成功连接"); &#125; //通过链接，发送statement preperStatement的区别是，可以预编译sql语句，再注入参数， Statement statement = conn.createStatement(); sql = "create table student(NO char(20),name varchar(20),primary key(NO))"; //返回影响行数 int i = statement.executeUpdate(sql); if (i!=-1)&#123; System.out.println("修改成功"); &#125; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; spring 开启事务spring 事务管理详解在xml配置文件中第一步：配置事务管理器第二步：开启事务注解 12345678910&lt;!-- 第一步：配置事务管理器 (和配置文件方式一样)--&gt; &lt;bean id="dataSourceTransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 注入dataSource --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 第二步： 开启事务注解 --&gt; &lt;tx:annotation-driven transaction-manager="dataSourceTransactionManager" /&gt; &lt;!-- 第三步 在方法所在类上加注解 --&gt;]]></content>
      <categories>
        <category>事务</category>
      </categories>
      <tags>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图]]></title>
    <url>%2F2019%2F09%2F07%2F%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[图是大大大]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位运算符]]></title>
    <url>%2F2019%2F09%2F07%2F%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[二进制的正负二进制的正负是从高位看，最高位如果1则是负数，如果是0则是正数。如果负数单纯是把最高位变为1的话，在运算中会出现不是我们想要的值，所以引入了：原码，反码，补码。正数的原码，反码，补码都一样，负数的反码是对除了符号位（最高位）对原码取反，补码是对反码+1（最高位不变）-5的原码是 1000 0000 0000 0101求出反码的是 1111 1111 1111 1010求出补码是 1111 1111 1111 1011 JAVA按位运算符1、“与”、“位与”（&amp;）按位“与”操作符，如果两个数的二进制，相同位数都是1，则该位结果是1，否则是0.例1 5&amp;45的二进制是 0000 0000 0000 01014的二进制是 0000 0000 0000 0100则结果是 0000 0000 0000 0100 转为十进制是4。2、“或”、“位或”（|）按位“或”操作符，如果两个数的二进制，相同位数有一个是1，则该位结果是1，否则是0例2 5 | 45的二进制是 0000 0000 0000 01014的二进制是 0000 0000 0000 0100则结果是 0000 0000 0000 0101 转为十进制是5。3、“异或、“位异或”（^）按位“异或”操作符，如果两个数的二进制，相同位数只有一个是1，则该位结果是1，否则是0（相同为0，不同为1） 例3 5 ^ 45的二进制是 0000 0000 0000 01014的二进制是 0000 0000 0000 0100则结果是 0000 0000 0000 0001 转为十进制是14、“非”、“位非”（~）也称为取反操作符按位“非”操作符，属于一元操作符，只对一个操作数进行操作，（其他按位操作符是二元操作符）。按位“非”生成与输入位相反的值，——若输入0，则输出1，若输入1，则输出0。例4 ~55的二进制是 0000 0000 0000 0101则~5是 1111 1111 1111 1010 转为十进制是 -6。 JAVA位运算符移位操作符操作的运算对象也是二进制的“位” 移位操作符只可用来处理整数类型，左移位操作符（&lt;&lt;）能按照操作符右侧指定的位数将操作符左边的操作数向左移动（在低位补0） 有符号”右移位操作符（&gt;&gt;）则按照操作符右侧指定的位数将操作符左边的操作数向右移。“有符号”右移位操作符使用“符号扩展”；若符号位正，则在高位插入0；若符号位负。则在高位插入1。 java中增加了一种“无符号”右移位操作符（&gt;&gt;&gt;）,他使用“零扩展”；无论正负，都在高位插入0。这一操作符是C或C++中所没有的。例6 5&lt;&gt;2 等于 15的二进制是 0000 0000 0000 0101右移两位 0000 0000 0000 0001例8 -5&gt;&gt;2 等于 -2 计算机中对于负数的计算都是通过补码。-5的二进制是 1111 1111 1111 1011右移两位 1111 1111 1111 1110 转十进制，例5反着来，先-1，然后取反 ————————————————版权声明：本文为CSDN博主「mxiaoyem」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/mxiaoyem/article/details/78569782 JAVA 基础数据类型的转换java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。自动转换按从低到高的顺序转换。int —-&gt; long —-&gt;float —-&gt; double int：int 数据类型是32位、有符号的以二进制补码表示的整数；最小值是 -2,147,483,648（-2^31）；最大值是 2,147,483,647（2^31 - 1）；一般地整型变量默认为 int 类型；默认值是 0 ；例子：int a = 100000, int b = -200000。 long：long 数据类型是 64 位、有符号的以二进制补码表示的整数；最小值是 -9,223,372,036,854,775,808（-2^63）；最大值是 9,223,372,036,854,775,807（2^63 -1）；这种类型主要使用在需要比较大整数的系统上；默认值是 0L；例子： long a = 100000L，Long b = -200000L。“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。 float：float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；float 在储存大型浮点数组的时候可节省内存空间；默认值是 0.0f；浮点数不能用来表示精确的值，如货币；例子：float f1 = 234.5f。 double：double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；浮点数的默认类型为double类型；double类型同样不能表示精确的值，如货币；默认值是 0.0d；例子：double d1 = 123.4。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发艺术编程]]></title>
    <url>%2F2019%2F09%2F03%2F%E5%B9%B6%E5%8F%91%E8%89%BA%E6%9C%AF%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[启动一个java程序，操作系统就会创建一个进程，一个进程可以创建多个线程，这些线程都用友各自的计数器，堆栈和局部变量等属性，访问共享的内存变量。JAVA程序天生就是多线程程序，执行main（）方法的是一个名为main的线程 为什么要多线程 更多的处理器核心 更多的响应时间 更好的编程模型线程优先级通过一个整型变量priority控制优先级，thread.setPriority(priority)。 默认优先级 ： 5 范围从 1-10，优先级逐级增高 对于优先级的选择 对于频繁阻塞的任务（休眠 或 I/O操作） ，优先级应该高。对于偏重计算的任务（需要较多的CPU） , 优先级应该低，确保处理器不会被独占注意 ：线程优先级不能作为程序正确性的依赖，因为操作系统可以完成不用理会JAVA线程对于优先级的设定，对线程优先级的设置会被忽略。线程中断中断好比其他线程对该线程打了个招呼，其他线程通过调用该线程的interrupt()方法对其进行了中断操作。等待/通知机制等待/通知机制，是指一个线程A调用了对象O的wait（）方法进入等待状态，而另一个线程B调用了对象O的notify（）或者notifyAll（）方法，线程A收到通知后从对象O的wait（）方法返回，进而执行后续操作。notify（）：通知一个在对象上等待的线程，使其从wait()返回，前提是获得对象的锁notifyAll（）：通知所有等待在该对象上的线程wait（）：调用该方法的线程进入waiting状态，只有等待另外线程的通知或中断才会返回，需要注意，调用wait（）方法后，会返回对象的锁。 使用wait() , notify() 和 notify() 时需要先对调用对象加锁。 notify（）或notifyAll（）方法调用后，等待线程依旧不会从wait返回，需要调用notify（）或notifyAll（）的线程释放锁后，才有机会。 notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll（）方法则是将等待队列中所有线程全部移到同步队列中，被移动的线程状态由waiting变为blocked 从wait（）方法返回的前提是获得了调用对象的锁。volatile关键字 —最轻量级的同步机制当一个变量被定义为volatile，两种特性 保证此变量对所有线程的可见性“可见性” ：当一个线程修改此变量，其他线程是立即得知新值。但由于JAVA里面的运算并非原子操作，导致volatile变量在并发下也并不安全。（例如 a++）。具有可见性和原子性，但类似于volatile++这种复合操作不具有原子性。通过字节码可以知道，其指令多了一个Lock前缀，使得本CPU的cache写入内存，该写入使得别的CPU无效其Cache，会重新从内存中读取，保证可见性。 禁止指令重排序优化（会干扰并发）保证变量赋值操作的顺序与程序代码中的执行顺序一致。通过内存屏障，使重排序时后面的指令不能比屏障之前的先执行。意味着所有之前的操作都已经执行完成。重排序：编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。Synchronized关键字，最基本的互斥同步手段Synchronize经过编译后，会在同步块前后分别形成两个monitorenter，monitorexit两个字节码指令。工作原理 –&gt;monitorenter –&gt;尝试获取对象的锁 —&gt;失败，线程阻塞—- &gt;成功，对象没被锁定，当前线程拥有对象的锁，锁的计数器加一— &gt; monitorexit —&gt;锁计数器减一 ，当计数器为0，锁就被释放 —&gt;唤醒被阻塞的线程锁释放 - 获取的内存语义与volatile写 - 读的内存语义是相同的 线程A释放一个锁（写一个volatile变量），实质上线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。 线程B获取了一个锁（读一个volatile变量），实质上是线程B接收了之前某个线程发出的（在释放之前对共享变量所做修改的）消息。 线程A释放锁，随后线程B获取锁，这个过程实质上是线程A通过主内存向线程B发送消息。实现多线程的几种方法 继承Thread类通过JDK提供的Thread类，重写Thread类run方法即可 123class Thread1 extends Thread&#123;...&#125;//启动 new Thread1().start; 实现Runnable接口 Runnable接口中仅定义一个run（）方法 1234class Thread2 implements Runnable&#123; @Override public void run()&#123;...&#125;&#125; 使用内部类的方式上面两种方式都需要再定义一个类，显得麻烦，通过匿名内部类实现，依然有两种 继承Thread a 实现 Runnable b 1234new Thread(new Runnable()&#123; @Override public void run()&#123;&#125;&#125;).start; 带返回值的callable实现callable接口 基于线程池的方式Thread.join()若一个线程A执行了thread.join()，含义是当前线程A等待Thread线程终止后才从join方法返回。锁锁的内部实现依赖于队列同步器同步器底层通过一个双向队列，存放工作队列，当一个线程成功获取同步状态，其他线程将无法获取到同步状态，转而被构造成为节点并加入同步队列中。可重入锁 自己可以再次获取自己的内部锁，任意线程在获取到锁之后能够再次获取该锁而不会被该锁所阻塞。Synchronize 和 基于Lock 实现的ReentrantLock都是可重入锁。 可重入锁 有两个特性 线程再次获取锁锁需要识别获取锁的线程是否是当前占据锁的线程，如果是，可再成功获取 锁的最终释放重复n次获取锁，在第n次释放锁后，其他线程才能获取到该锁 读写锁维护一对锁，一个读锁，一个写锁。通过分离读锁，写锁提高效率。JAVA并发包提供读写锁的实现是 ReetrantReadWriteLock。 123ReetrantReadWriteLock rwl = new ReetrantReadWriteLock();Lock r = rwl.readLock(); // 读锁Lock w = rwl.writeLock(); // 写锁 公平性选择 默认是非公平性 重进入锁 锁降级 先拿读锁（保证可见性） 放读锁，拿写锁，再拿读锁。读写锁的实现是通过int变量维护多种状态，读写锁将变量切分，高16位表示读，低16位表示写。ReentrantLock ***重点 通过调用Lock（）方法获取锁，unlock（）释放锁 12ReentrantLock lock = new ReentrantLock();lock.lock() ; lock.unlock(); 实现依赖于AQS框架，使用一个整型的volatile变量（state）来维持同步 **重点 公平锁的实现 *重点happens-before程序顺序规则是JMM核心的概念JMM通过happens-before来指定两个操作之间的执行顺序定义： ①如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个可见，且第一个操作的执行顺序排在第二个之前 ———————-对程序员可见②如果一个操作happens-before另一个操作，并不意味着必须按照happens-before关系指定的顺序执行，如果重排序之后的执行结果，与按happens-before顺序结果一致，那么这种重排序并不违法。 ————————对编译器和处理器的约束原则CAS 比较与替换是设计并发算法时用到的技术CAS是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值1234567public class MyLock&#123; private AtomicBoolean locked = nnew AtomicBoolean(false); public boolean lock()&#123; return locked.compareAndSet(false,true); &#125; //比较locked 和 false ，如果相等，则把它修改成true&#125; ConcurrentHashMap 是线程安全且高效的HashMapConcurrentHashMap的锁分段技术可有效提升并发访问率 与HashTable容器相比，HashTable容器并发环境效率低下是所有访问HashTable的线程都必须访问同一把锁。假如容器中有很多锁，每把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不存在竞争。这就是ConcurrentHashMap的锁分段技术。 ConcurrentHashMap的结构是有Segment数组结构 和 HashEntry 数组结构组成 Segment是一种可重入锁，结构和HahMap类似，是一种数组和链表结构。 一个ConcurrentHashMap里包含一个Segment数组，扮演锁的角色。 每个HashEntry是一个链表结构的元素，一个Segment里包含一个HashEntry数组。 每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得与他对应的Segment锁。get操作 在定位Segment时，都会对元素的hashcode进行一次再散列。在HashTable中，get方法是需要加锁的，但在ConcurrentHashMap中的get操作是不用加锁的。原因： 在它的get方法中将要使用的共享变量都定义成volatile类型。能够在线程之间保持可见性，能够被多线程读，但只能被单线程写（有种情况可被多线程写，就是写入的值不依赖原值）。就像有多线程写， 也能get（）到最新的值。根据JMM的happens-before规则，对volatile的写入操作时优先于读操作的。这是用volatile替换锁的经典场景。put操作put方法首先定位到Segment,然后在Segment里进入插入操作。ConcurrentHashMap的扩容首先会创建一个容量是原来容量两倍的数组，然后将原来的元素再散列插入到新数组中。为了高校，ConcurrentHashMap不会对整个容器进行扩容，而只对某个Segment进行扩容。比HashMap更高校，HashMap是在插入后进行判断是否需要扩容， 但扩容后可能就不插入新元素。浪费了扩容的其他空间。阻塞队列（BlockingQueue）是一个支持两个附加操作的队列，这两个附加的操作支持阻塞的插入和移除 支持阻塞的插入方法，意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。 支持阻塞的移除方法，当队列为空时，会阻塞移除元素的线程，等待队列不为空。并发工具类等待多线程完成的CountDownLatchCountDownLatch允许一个或多个线程等待其他线程完成操作。假如需求，解析一个Excel里多个sheet的数据，每个线程解析一个sheet，等所有的sheet都解析完，程序需要提示解析完成。实现主线程等待所有线程完成sheet的解析，最简单是使用join（）方法1234Thread1.start();Thread2.start();Thread1.join(); //主线程需等待join线程执行结束。THread2.join(); CountDownLatch c = new CountDownLatch(2);CountDownLatch接收一个int类型的参数作为计数器，如果想等待N个点完成，这里就传入N。调用c.countDown()方法，N就会-1,c.await()方法会阻塞当前线程，直到N变成0； 同步屏障 CyclicBarrier让一组线程到达一个屏障（同步点）时被阻塞，直至最后一个屏障到达才会开门，所有被屏障拦截的线程才会继续运行。每个线程调用await（）告诉其已到屏障。new CyclicBarrier（2）; 如果修改成3，但只有两个线程调用await（），主线程和子线程和永远等待，因为没有第3个线程执行await方法，即没有第3个线程到达屏障，所以之前到达屏障的线程都不会执行。 CountDownLatch 和 CyclicBarrier的区别CountDownLatch的计数器只能使用一次， CyclicBarrier的计数器可以使用reset（）重置。 线程池的实现原理 线程池判断核心线程池里的线程是否都在执行任务（运行的线程少于corePoolSize，核心线程池还能添加工作线程），则创建新的工作线程来执行任务。（线程池创建线程时，会将线程封装成工作线程worker，Worker在执行任务后，还会循环获取工作队列里的任务来执行）若工作线程都在执行任务，且核心线程池已满，则进入下个流程。注意：创建新线程这一步需要获取全局锁，消耗资源。 线程池判断能否将任务加入工作队列，可以则加入工作队列FIFO，不可以则创建新线程。 如果创建新线程将使当前运行的线程超过MaxnumPoolSize（线程池大小），则交由饱和策略。线程池的创建 通过ThreadPoolExecutor来创建new ThreadPoolExecutor（corePoolSize–线程池基本大小，MaxnumPoolSize—线程池最大数量，keepAliveTime，millsecond，runnablequeue—保存任务的阻塞队列，hanlder—饱和策略）向线程池提交任务 threadPool.execute (new Runnable(){…})execute()方法用于提交不需要返回值的任务。（无法判断任务是否成功） Future(Object) future = threadPool.submit(new Runnable{})submit()方法用于提交需要返回值的任务，会返回一个future对象，并且可以通过future的get（）方法来获取返回值，get（）会阻塞当前线程直到任务完成。关闭线程池threadPool.shutdown();原理：遍历工作线程，逐个调用线程的interrupt方法中断线程。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2019%2F09%2F02%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序的稳定性假设在排序前的序列中ri 领先于rj(即i&lt;j)。如果排序后ri仍领先于rj，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中rj领先ri,则称所用的排序方法是不稳定的。 冒泡排序冒泡排序一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。1234567891011//对顺序表做冒泡排序void BubbleSort(SqList list)&#123; int i,j; for (i = 1;i&lt;list.length;i++)&#123; for (j = list.length-1;j&gt;=i;j--)&#123; //注意j是从后往前递减 if(list[j-1]&gt;list[j])&#123; //若前者大于后者 swap(list,j-1,j); //交换前者和后者的位置 &#125; &#125; &#125;&#125; 较小的数字如同气泡般慢慢浮到上面，因此将此算法命名为冒泡排序。 冒泡排序优化如果待排序的序列是{2,1,3,4,5,6,7,8}，也就是说，除了第一和第二的关键字需要交换外，别的已经是正常的顺序。当i=1时，交换了2和1，此时序列已将有序，但是算法仍然将i=2到8都执行了一遍，尽管没有交换数据，但是之后的大量比较大大的多余。当i=2时，我们已经对9与8,8与7……3与2作了比较，没有任何数据交换，这就说明此序列已将有序，不需要再继续后面的循环判断工作。为了实现这个想法，需要改进代码，增加一个标记变量flag来实现算法的改进。12345678910111213void BubbleSort2(SqList list)&#123; int i,j; Boolean flag = false; //flag用来做标记 for (i = 1;i&lt;list.length &amp;&amp; flag;i++)&#123; //若flag为false则退出循环 flag = false; //初始flag为false for (j = list.length-1;j&gt;=i;j--)&#123; if(list[j-1]&gt;list[j])&#123; swap(list,j-1,j); flag = true; //若发生交换，flag=true &#125; &#125; &#125;&#125; 复杂度分析最好的情况，排序的表本身就是有序的，根据最后改进的代码，可以推断出就是n-1次的比较，没有数据交换，时间复杂度是O(n)。最坏的情况，即排序表时逆序的情况，此时需要比较1+2+3+4+5…+（n-1）= n(n-1)/2次，因此，总的时间复杂度为O(n2)。 简单选择排序选择排序法的初步思想，冒泡排序的思想是不断的交换，通过交换完成最终的排序，我们可以在排序时找到合适的关键字再做交换，并且只移动一次就完成相应关键字的排序定位工作。简单选择排序法就是通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i个记录交换之。123456789101112131415/*对顺序表L作简单选择排序*/void SelectSort(SqList list)&#123; int i,j,min; for (i=1;i&lt;list.length;i++)&#123; min = i; //将当前下标定义为最小值下标 for(j=i+1;j&lt;list.length;j++)&#123; if (list[min] &gt; list[j])&#123; //从n-i+1中选出关键字最小的记录 min = j; //将此关键字的下标赋值给min &#125; &#125; if (min != i)&#123; //若min不等于i,找到最小值，交换 swap(list,i,min); //交换list[i]和list[min]的值 &#125; &#125;&#125; 简单选择排序复杂度分析从过程来看，它最大的特点就是交换移动数据次数相当少，这样也就节约了相应的时间。分析复杂度发现，无论最好最坏情况，其比较次数都是一样的多，第i趟排序需要进行n-i次关键字的比较，此时需要比较n-1+n-2+…=1 = n(n-1)/2次。因此，总的时间复杂度依然是O(n2).应该说，尽管与冒泡排序同为O(n2),但简单选择排序的性能上还是要略优于冒泡排序。 直接插入排序直接插入排序的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的，记录数增1的有序表。12345678910111213void InsertSort(SqList list)&#123; int i,j; //0的位置当成哨兵，假设list[1]已经排好位置，后面的牌其实就是插入到它的左侧还是右侧的问题 for (i = 2,j&lt;=list.length;i++)&#123; if (list[i] &lt; list[i-1])&#123; //升序，需将list[i]插入有序子表 list[0] = list[i]; //设置哨兵 for (j=i-1;list[j]&gt;list[0];j--) &#123; list[j+1] = list[j]; //记录后移 &#125; list[j+1] = list[0]; //插入到正确位置 &#125; &#125;&#125; 直接插入排序时间复杂度分析最好的情况，也就是要排序的表本身就是有序的，那么比较次数，其实就是代码第6行每个list[i]与list[i-1]的比较。时间复杂度为O(n)。最坏的情况，2+3+4+…+n=(n+2)(n-1)/2,直接插入排序的时间复杂度为O(n2),同样的O(n2)时间复杂度，直接插入排序法比冒泡和简单选择排序的性能要好一些。 希尔排序在这之前排序算法的时间复杂度基本都是O(n2)，希尔排序算法是突破这个时间复杂度的第一批算法之一。在直接插入排序的基础上进行改进。将原本有大量记录数的记录进行分组，分割成若干序列，采取跳跃分割的策略：将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。12345678910111213141516171819//对顺序表L做希尔排序//将关键字较小的记录，不是一步一步地往前挪动，而是跳跃式地往前移，使得每完成一轮循环后，整个序列就朝着有序坚持地迈进了一步void SheelSort(SqList list)&#123; int i,j; int increment = list.length(); do &#123; increment = increment/3 +1; //增量序列 for(i=increment+1;i&lt;=list.length();i++)&#123; if (list[i] &lt; list[i-increment])&#123; //跳跃判断 list[0] = list[i]; //暂存在list[0] for (j = i-increment;j&gt;0&amp;&amp;list[0]&lt;list[i];j-=increment)&#123; list[j+increment] = list[j]; //记录后移，查找插入位置 &#125; list[j+increment] = list[0]; //插入 &#125; &#125; &#125;while(increment&gt;1); //当增量为1时，就停止循环&#125; 希尔排序复杂度分析希尔排序的关键并不是随便分组后各自排序，而是将相隔某个“增量”的记录组成一个子序列，实现跳跃式的移动，使得排序的效率提高。其时间复杂度为O(n3/2)，要好于直接排序的O(n2)，需要注意的是，增量序列的最后一个增量值必须等于1才行，另外记录是跳跃式的移动，希尔排序并不是一种稳定的排序算法。 堆排序前面讲到简单选择排序，他在待排序的n个记录中选择一个最小的记录需要比较n-1次，本来可以理解，查找第一个数据需要比较这么多次是正常的，可惜的是，这样的操作并没有把每一趟的比较结果保存下来，在后一趟的比较中，有许多比较在前一趟已经做过了，但由于前一趟排序时未保存这些比较结果，所以后一趟排序时又重复执行了这些比较操作，因而记录的比较次数较多，如果可以做到每次在选择到最小记录的同时，并根据比较结果对其他记录做出相应的调整，那排序的总体效率就会非常高。而堆排序就是对简单排序进行的一种改进。同时，他们发明了“堆”这样的数据结构。 堆堆是具有下列性质的完成二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆。或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。根结点一定是堆中所有结点最大（小）者。如果按照层序遍历的方式给结点从1开始编号，则结点之间满足如下关系：完全二叉树的特性，下标i与2i和2i+1是双亲子女关系。核心 大顶堆：ki &gt;= k2i , ki &gt;= k2i+1 小顶堆： ki &lt;=k2i , ki&lt;=k2i+1 ( 1&lt;= i &lt;= n/2 )堆排序利用此规则，完成排序。 堆排序算法将要排序的数组，看成是按照层序遍历的完全二叉树。堆排序就是利用堆（假设利用大顶堆）进行排序的方法。它的基本思想是，将待排序的序列构造成一个大顶堆，此时整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素的次大顶堆，如此反复执行，便能得到一个有序序列。12345678910111213141516171819//本函数调整list[s]的关键字，使list[s..m]成为一个大顶堆//s 根节点 ，m 数组长度void HeadAdjust(SqlList list,int s,int m)&#123; int temp,j; temp = list[s]; for (j=2*s;j&lt;=m;j*=2)&#123; //沿关键字较大的孩子结点向下筛选 //找出s结点下，最大的孩子结点。j为关键字中较大的记录的下标。 if (j&lt;m &amp;&amp; list[j]&lt;list[j+1])&#123; ++j; &#125; if (temp &gt;= list[j])&#123; break; //根节点是最大的值，不需要改变位置 &#125; list[s] =list[j]; //将根节点与孩子结点数值交换， //s替换为j,进入下一次循环，看是否需要与下一个根节点互换 s=j; &#125; list[s] = temp; //将孩子结点换成根节点的数值&#125; 堆排序的核心算法已经有了，接下来就是对数组进行排序。12345678910void HeapSort(SqList list)&#123; int i; for (i = list.length()/2;i&gt;0;i--)&#123; ** HeadAdjust(list,i,list.length()); //把list构建成一个大顶堆 &#125; for (i = list.length() ;i&gt;1;i--)&#123; swap(list,1,i); //将堆顶记录和当前子序列的最后一个记录交换。 HeadAdjust(list,1,i-1); //将list[1..i-1]重新调整为大顶堆 &#125;&#125; 假设list长度是9，从4往下递减，是因为都是有孩子的结点。我们所谓的将待排序的序列构建成为一个大顶堆，其实就是从下往上，从右往左，将每个非终端结点（非叶结点）当成根节点，将其和其子树调整成大顶堆。 堆排序的时间复杂度堆排序的运行时间主要是消耗在初始构建堆和重建堆时的反复筛选上。在构建堆的过程中，因为我们是完成二叉树从最下层最右边的非终端结点开始构建将它与其孩子进行和若有必要的互换，对于每个非终端结点来说，其实最多进行两次比较和互换操作，因此整个构建堆的时间复杂度为O(n)。在正式排序时，第i次取堆顶记录重建堆需要用O(logi)的时间（完全二叉树的某个结点到根节点的距离为logi+1）,并且需要去n-1次堆顶记录，因此，重建堆的时间复杂度为O(nlogn)。所以，总体来说，堆排序的时间复杂度为O(nlogn). 归并排序前面我们讲 了堆排序，因为它用到了完全二叉树，充分利用了完全二叉树的深度是log2n + 1的特性，所以效率比较高。不过堆结构的设计本身是比较复杂的，有没有更直接简单的方法利用完成二叉树来排序。当然有。归并排序法涉及到完全二叉树结构的排序算法。归并排序就像是一颗倒置的完全二叉树 归并排序算法归并排序就是利用归并的思想实现的排序方法。他的原理是假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到[n/2]个长度为2或1的有序子序列，再两两归并，…..,如此重复，直至得到一个长度为n的有序序列位置，这种排序方法称为2路归并排序。12345678910111213141516//对顺序表L作归并排序void MergeSort(Sqlist list)&#123; Msort(list,list,1,list.length());&#125;void Msort(int sr[],int tr1[],int s,int t)&#123; int m; int tr2[MAXSIZE+1]; if (s == t)&#123; //当细分到一个记录填入tr2后，此时s和t相等，递归返回 tr1[s] = sr[s]; &#125;else&#123; m = (s+t) /2; //将sr[s..t]平分为sr[s..m]和sr[m+1..t] 10 Msort(sr,tr2,s,m); //递归将sr[s..m]归并为有序的tr2[s..m] Msort(sr,tr2,m+1,t); //递归将sr[m+1..t]归并成有序的tr2[m+1..m] 12 Merge(tr2,tr1,s,m,t); //将tr2[s..m]和tr2[m+1..t],归并到tr1[s..t] &#125;&#125; 看第10行继续递归进去后，直到细分为一个记录填入tr2,此时s与t相等，递归返回，每次递归返回后都会执行当前递归函数的第12行，将tr2归并到tr1中，最终使得当前序列有序。现在我们来看看Merge函数的代码是如果实现的。123456789101112131415161718192021//sr[] 待归并的数组，tr[]归并排序后的数组，i=1，m正中间值,n数组长度void Merge(int sr[],int tr[],int i,int m,int n)&#123; int j,k,l; //k记录tr数组坐标。 j记录sr数组右半段数组下标 for (j = m+1,k=i;i&lt;=m &amp;&amp; j&lt;=n;k++)&#123; //将sr中记录由小到大归并到tr if (sr[i] &lt;sr[j])&#123; tr[k] = sr[i++]; //将前后两段数组进行对比，牛逼 &#125;else&#123; tr[k] = sr[j++]; &#125; &#125; if (i &lt;=m)&#123; //将没有归并到tr的sr[1..m]复制到tr for(l=0;l&lt;m-i;l++)&#123; tr[k+1]=sr[i+1]; &#125; &#125; if (j &lt;=n)&#123; //将没有归并到tr的sr[m+1..n]复制到tr for(l=0;l&lt;n-j;l++)&#123; tr[k+1]=sr[i+1]; &#125; &#125;&#125; 归并排序复杂度分析总的时间复杂度为O(nlogn),这是归并排序算法中最好，最坏，平均的时间性能。归并排序Merge函数中有if（sr[i]&lt;sr[j]）,这就说明它需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法。 快速排序希尔排序相当于直接插入排序的升级，堆排序相当于简单选择排序的升级，它们同属于选择排序类，而快速排序其实就是最慢的冒泡排序的升级，都属于交换排序类，只不过它的实现，增大了记录的比较和移动的距离，将关键字较大的记录从前面直接移动到后面，关键字较小的记录从后面直接移动到前面，从而减小了总的比较次数和移动交换次数。 快速排序算法快速排序的基本思想是:通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。1234567891011121314151617181920212223242526//对顺序表L的子序列作快速排序void QSort(SqList list , int low ,int high)&#123; int pivot; if (low &lt; high)&#123; pivot = Partition(L,low,high); //将list一分为二 算出枢轴值pivot Qsort(list,low,pivot-1); //对低子表递归排序 Qsort(list,pivot+1,length); //对高子表递归排序 &#125;&#125;int Partition(SqList list,int low ,int high)&#123; int pivotkey; pivotkey = list[low]; //用子表的第一个记录做枢轴记录 while(low &lt; high)&#123; //将第一个记录作为枢轴，则一定要从后往前扫 while (low &lt;high &amp;&amp; list[high] &gt;=pivotkey)&#123; high --; &#125; swap(list,low,high); //将比枢轴小的记录交换到低端 while(low &gt;high &amp;&amp; list[low] &lt;=pivotkey)&#123; low ++; &#125; swap(list,low,high); //将比枢轴大的记录交换到高端 &#125; return low; //返回枢轴所在位置&#125; 快速排序时间复杂度分析在最优的情况下，快速排序算法的时间复杂度为O(nlogn)。最坏情况下，其时间复杂度是O(n*n)。快速排序是一种不稳定的排序方法。java对快速的实现 java.util.Arrays —-&gt; static void sort(type[] a)]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归]]></title>
    <url>%2F2019%2F08%2F21%2F%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[http://lylblog.cn/blog/4]]></content>
  </entry>
  <entry>
    <title><![CDATA[react框架]]></title>
    <url>%2F2019%2F08%2F09%2Freact%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[通过react脚手架创建项目create-react-app [项目名] 启动脚手架npm start打包生产环境npm run build JSXJSX本身也是一种表达式 组件 组件是可以复用的UI元素]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习网站]]></title>
    <url>%2F2019%2F08%2F08%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[React官方文档 https://reactjs.org/ECMAScript 6入门 http://es6.ruanyifeng.com/（特别是解构赋值、箭头函数和 Class）MDN - JavaScript https://developer.mozilla.org/zh-CN/docs/Web/JavaScript（JS基础语法）MDN - Array.prototype.map() https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map（数组map方法） ES6入门javaScript JavaScript里一切皆对象，一切皆可储存在变量里。 let 声明变量。 浏览器出现Cannot set property ‘onclick’ of null的问题浏览器先加载玩按钮节点才执行的js ,所以当浏览器自顶向下解析时，找不到onclick绑定的按钮节点。因此，需要把js文件放在底部加载，就会避免该问题 ES6 中let 命令，用来声明变量，所声明的变量，只在let命令所在的代码块中有效。var命令声明的，在全局范围内都有效 1234567 for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc'; console.log(i);&#125;// abc// abc// abc 上面代码正确运行，输出了 3 次abc。let 命令在for循环中，函数内部变量的i,与循环变量i不在同一个作用域。 变量的结构赋值 1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = ["foo", "bar", "baz"];third // "baz"let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // "a"y // undefinedz // [] 解构失败例子12let [foo] = [];let [bar, foo] = [1]; 等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。 12345678 let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis]]></title>
    <url>%2F2019%2F08%2F07%2Fredis%2F</url>
    <content type="text"><![CDATA[本地mysql密码 666666 1.1本地redis地址D:\installations\rediswindows下redis启动redis-server.exe redis.windows.conf 1.2port 6379]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>nosql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据锁]]></title>
    <url>%2F2019%2F08%2F06%2F%E6%95%B0%E6%8D%AE%E9%94%81%2F</url>
    <content type="text"><![CDATA[解决并发问题，数据库常用的两把锁]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux]]></title>
    <url>%2F2019%2F08%2F05%2FLinux%2F</url>
    <content type="text"><![CDATA[1. vim编辑器一般模式：编辑模式：[i,0,a,r] , [ESC] 退出指令列命令模式 ：[: / ?]:wq 保存后退出:q! 强制退出不保存 Linux的分类：1.内核版本：Linux不是一个操作系统，严格来讲，只是一个操作系统的内核。内核建立计算机软件和硬件之间通讯的平台。2.发行版本：一些组织或公司在内核上进行二次开发的版本。Linux一个重要概念，一切都是文件。 Linux常用命令 mkdir：增加目录 rmdir：删除目录 ls 或 ll :( ll 是ls -l缩写 ll可看到该目录下所有目录和文件的详细信息 ) find 目录 参数 :寻找目录eg : find . -name ‘x.txt’ -o -name ‘x.pdf’当前目录及子目录下 所有以 .txt , .pdf结尾的文件 mv 目录名称 新目录名称 （改名）mv 目录名称 目录新位置 （剪切） cp -r 目录 目录新名字 （拷贝，-r递归拷贝） rm [-rf] 目录 ：删除目录tar -zcvf 压缩后的名字 要打包的文件-s 还原文件的顺序和备份文件内的存放顺序相同。-t 列出备份文件的内容。-v 显示指令执行过程。-f 指定压缩文件-x 从备份文件中还原文件。tar -xvf 压缩文件 -x 解压 Linux 查看负载 uptime 显示当前机器负载 w 列出所有user分别的情况 top wa超10%表示IO压力很大。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务架构]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[idea编码Enoding 记得设置UTF-8spring-boot如官网所说，帮我们构建一个spring项目，直接可以运行。微服务架构，将每一个模块均分成每一个项目。每个项目之间通过接口等，相互联系。将项目拆分几个独立的功能单元（服务） 的架构 优点 技术异构性：开发者可以自由的选择合理的技术和框架，只要服务遵守API协定即可。 弹性：将不同服务部署在不同机器上，降低整体功能不可用的概率 可扩展性：可以只对需要扩展的服务进行扩展 简化部署：各个服务模块福利部署，可以快速对特定代码进行更新。缺点 实现复杂度搞 测试微服务复杂。对于微服务的一个类似的测试则需要运行该服务以及依赖的服务，也可能会增加额外的沟通成本。 分割的数据库架构：对于微服务间的事务性操作，因为不同的微服务采用了不同的数据库，将无法利用数据库本身的事务机制保证一致性。 接口匹配问题。服务依赖于彼此间的接口进行通信。改变一个服务的接口会对其他服务造成影响。 部署复杂 运维复杂SpringCloudSpringCloud是基于SpringBoot提供了一套为微服务解决方案，包括服务注册与发现。 Eureka:服务发现/注册中心，用于定位服务。 Hystrix:熔断器，容错管理工具。 Zuul：是在云平台上提供动态路由，监控，弹性，安全等边缘服务的框架 Ribbon/Feign:客户端负载均衡1.1 微服务架构 - 常见微服务框架 Dubbo/Dubbox 一个分布性，高性能，透明化的RPC服务框架 阿里巴巴开发 ， 当当改良 基于RPC Spring Cloud Spring团队开发 基于RESTful1.2 微服务架构 - 通信方式 RPC Remote Procedure Call 支持RPC的微服务框架：Dubbo/Dubbox 基于TCP,平台有关 RESTful Representational State Transfer 支持RESTful 的微服务框架：Spring Cloud/Dubbox 基于HTTP，平台无关其他概念 — 分布式和集群 分布式 关注项目拆分（水平拆分，垂直拆分） 集群关注项目部署 1.3 主要组件Eureka：服务发现/注册中心，一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移Spring Cloud Eureka是对Netflix的Eureka的进一步封装。Hystrix：熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力Zuul：Zuul 是在云平台上提供动态路由,监控,弹性,安全等边缘服务的框架Ribbon/Feign：客户端负载均衡，Feign是一种声明式、模板化的HTTP客户端Turbine：集群监控Springcloud-config：配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git以及SubversionSpringcloud-bus：轻量级消息代理Springcloud-sleuth/zipkin：链路追踪Springcloud-security：基于spring security的安全工具包，为你的应用程序添加安全控制 问题小结Feign客户端customer在启动类中添加客户端EnableFeignClients12345//Eureka客户端@EnableEurekaClient@SpringBootApplication//Feign客户端@EnableFeignClients 当无法注入bean时，可以通过@Configuration手动注入@bean123456789101112@Configurationpublic class FeignConfig &#123; @Bean public UserFeignClient userFeignClient()&#123; return new UserFeignClient() &#123; @Override public String login() &#123; return null; &#125; &#125;; &#125;&#125; Feign,http客户端，替服务发送http请求，解决接口调用问题。使用lombok插件时，Intellij idea开发的话需要安装Lombok plugin，同时设置 Setting -&gt; Compiler -&gt; Annotation Processors -&gt; Enable annotation processing勾选。 容错处理Hystrix（容错机制应该深入理解下），解决调用过程中的异常处理基于feign整合hystrix采用熔断器机制，就像try….catch….一样。通过在调用者实现feign接口，实现具体的失败业务逻辑。 12345678// 注入spring容器中@Component public class UserFeignclientFallback implements UserFeignClient &#123; @Override public Boolean login(User user) &#123; return false; &#125;&#125; 在接口定义中，添加fallback = UserFeignclientFallback.class(发生宕机后处理错误的类)字段，当服务宕机，则执行这个方法。123456@FeignClient(name = "provider-demo",fallback = UserFeignclientFallback.class)public interface UserFeignClient &#123; @RequestMapping(value = "/login",method = RequestMethod.POST) public Boolean login(@RequestBody User user);&#125; Ribbon解决负载均衡的一个组件Nginx解决服务端（被调用方）负载均衡————–Ribbon是解决客户端（调用方）调用默认分配策略是平均分配。 案列测试 123&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;&lt;/dependency&gt; 先集群provider服务（通过springboot复制一个新服务，设置端口号-Dserver.port=8082） 通过发起多次请求可以发现，ribbon默认算法是均衡的（你一次我一次。） 更换ribbon的负载均衡策略。在调用者方更改。即customer12345# 更改ribbon的负载算法 provider-demo: ribbon: #随机策略算法 NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule Zuul微服务网关 例如filter，对进入服务的请求进行过滤 springcloud实现的过滤器。 ########## 具体实现 通过继承ZuulFilter ，实现默认方法 注入spring容器 12345yml文件中zuul:routes: # 对路径是带有user的，则认为是要进入customer，执行网关拦截。/user --》网关入口 customer-demo: /user/** 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 @Componentpublic class PreFilter extends ZuulFilter &#123; /*** * 过滤器类型,过滤器运行时间 * FilterConstants.PRE_TYPE == pre .相当于pre （前置，中，后置等） * @return */ @Override public String filterType() &#123; return FilterConstants.PRE_TYPE; &#125; /** * 同级别过滤器优先级，数越大越低 * @return */ @Override public int filterOrder() &#123; return 0; &#125; /*** * 过滤器是否发挥作用,对于过滤器的控制更加灵活 * @return */ @Override public boolean shouldFilter() &#123; return true; &#125; /*** * 过滤器做的事情 * @return * @throws ZuulException */ @Override public Object run() throws ZuulException &#123; //通过requestContext实现接口之间的信息传递 RequestContext context = RequestContext.getCurrentContext(); //通过context拿request请求 HttpServletRequest httpServletRequest = context.getRequest(); /* //在请求头中拿用户验证的token 测试验证 String token = httpServletRequest.getHeader("token"); if (token == null || token.equals(""))&#123; context.setSendZuulResponse(false); context.setResponseStatusCode(401); context.setResponseBody("&#123;\"msg\":\"401,access without permission,login first.\"&#125;"); return "access denied"; &#125; return "pass";*/ String key = httpServletRequest.getParameter("key"); System.out.println(key+"filter 1"); if ("1".equals(key))&#123; context.setSendZuulResponse(false); &#125; return null; &#125;&#125; 过滤器之间的协调作用通过request，context传递信息12345678//通过requestContext实现接口之间的信息传递RequestContext context = RequestContext.getCurrentContext();//通过context拿request请求HttpServletRequest httpServletRequest = context.getRequest(); context.sendZuulResponse(); 获取到上一个过滤器的状态 config 分布式配置 访问路径 /项目名/版本/分支 （get请求）http://localhost:7900/gateway-zull/dev/springcloud在远程仓库上，关于配置文件的命名规范 前缀：/项目名-版本号.properties dev 开发环境 pro 生产环境 test 测试环境远程配置管理，将公共配置集中起来，统一管理通过git配置，将一些配置文件的信息，配置到项目中来 1.添加config依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt; 2. 修改配置信息123456789cloud: config: server: git: uri: https://github.com/czetao/config-server.git username: czetao password: ilzzr888 # 如果不是在根目录下，需要标注下一个包 search-paths: config-file 3. 在启动类上，添加configserver注解。12@EnableDiscoveryClient@EnableConfigServer]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目小记]]></title>
    <url>%2F2019%2F07%2F29%2Fvue%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[win + Q 打开搜索框npm 与 cnpm 的区别DOM （Document Object Model）是指文档对象模型，通过它，可以访问html文档的所有元素。 下载cnpm(淘宝镜像，更快)npm install cnpm -g –registry=https://registry.npm.taobao.org 全局安装vue -clicnpm install -g vue-cli npm i install下载安装模块vue项目管理系统环境搭建使用vue脚本架搭建工程vue init webpack vuetest(项目名)package.json 总项目的js控制文件启动项目 npm run dev 集成elementUI组件npm i element-ui -S12345//引入element-ui 样式 main.jsimport ElementUI from 'element-ui';import 'element-ui/lib/theme-chalk/index.css';//注册elementuiVue.use(ElementUI); 使用axiosnpm install axios –save 123456789101112//在main.js中引入axiosimport axios from 'axios'//挂载在Vue的原型上。Vue.prototype.axios = axios//通过代理方式，将请求地址代理到888端口下，即解决跨域 this.axios.post('/api/checklogin',&#123; username : that.loginForm.username, password : that.loginForm.password &#125;) .then(response =&gt; &#123; console.log("接收后端响应请求的数据：" ,response.data) &#125;) 通过axios与后端交互。 使用express+node.js快速搭建后台。通过后台的/routes/index.js文件，接收请求123router.post("/checklogin",(req,res) =&gt; res.send("1")) //全局安装expressnpm install express-generator -gexpress -e server 使用nodemon工具启动项目 记得给安装新项目中的模块。cnpm installnpm install -g nodemon12//启动后台服务nodemon app 出现跨域错误error : changeOrigin通过自己添加一个代理 解决1234567891011proxyTable: &#123; '/api': &#123; target: 'http://localhost:888/', //目标接口域名 changeOrigin: true, //是否跨域 pathRewrite: &#123; '^/api': '/api' //重写接口 &#125; &#125; &#125;, 这段代码的效果就是将本地8080端口的一个请求代理到了http://www.abc.com这一域名下： 'http://localhost:8080/api' ===&gt; 'http://localhost:888/api' sql 语法当使用${}拼接时，sql应该用套起1const sql = `select * from users where username='$&#123;username&#125;' and password='$&#123;password&#125;'` 使用vuex做到数据之间的共享cnpm i vuex –save通过vuex中的state做到一个全局变量的储存，形同与小程序的全局变量localstore。通过定义mutations操作state123456const mutations = &#123; SAVE_USERINFO(state,userinfo)&#123; console.log("函数被触发"); state.userinfo = userinfo; &#125;&#125; 通过commit 触发函数1$store.commit('SAVE_USERINFO',data); 在样式中加个!imporant路由出口 在属性列表 增添router属性 使用vuex中mapState 获取state数据vuex中state 是保存全局状态的常用方法。改变state通过改变提交方式123456789101112//状态 const state = &#123; userinfo : JSON.parse(localStorage.getItem('userinfo'))&#125;//mutations 主要用来操作stateconst mutations = &#123; SAVE_USERINFO(state,userinfo)&#123; //存入本地 需要将对象转成字符串 localStorage.setItem('userinfo',JSON.stringify(userinfo)) state.userinfo = userinfo; &#125;&#125; 通过vuex actions 异步获取所有数据mapState 辅助组件给state状态中的属性映射。通过提交computed方法123456789101112import &#123;mapState&#125; from 'vuex';computed :&#123; // username ()&#123; // return this.$store.state.userinfo.username // &#125;, //通过mapState 辅助函数获取state数据 ...mapState(&#123; userinfo :state =&gt; state.userinfo, username :state =&gt; state.userinfo.username &#125;) &#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客java小结]]></title>
    <url>%2F2019%2F07%2F26%2F%E7%89%9B%E5%AE%A2java%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[零散知识存在继承的情况下，初始化顺序为： 父类（静态变量，静态代码块） 子类（静态变量，静态代码块） 父类（实例变量，普通代码块） 父类（构造函数） 子类（实例变量，普通代码块） 子类（构造函数） 继承：在继承关系之中，如果要实例化子类对象，会默认先调用父类构造，为父类之中的属性初始化，之后再调用子类构造，为子类之中的属性初始化，即：默认情况下，子类会找到父类之中的无参构造方法。 牛客java 捕捉到异常时 ， 程序就会停止运行 ，抛出异常 重载 ：仅返回值类型不同时， 不足以构成重载 。重载的基本条件 参数类型不同 参数次序不通过 参数个数不同 重写 ： 函数名， 函数参数，返回值 应该相同 true false null sizeof 不是java的关键字 ， 但是也不能当成java标识符用const goto 是java的保留字（关键字） boolean 的默认值是false this() 和 super() 为构造方法，作用是在jvm 堆中构建出一个对象 。因此避免多次创建对象，同一个方法中只能调用一次this（ ） 和super() . 且必须在第一行实现，避免操作对象时，对象还未构建成功。 实例一个内部类 异常通常分为编译时异常， 运行异常 。编译时异常需要手动进行捕捉处理（文件不存在），运行时异常只有在编译器编译运行才会出现，不需要自己手动捕捉（空指针异常，溢出） 对于外部类来说 ， 只有两种修饰，public 和默认（default ） A instanceOf B ,是判断对象A 是否属于B 或B的子类，子类接口实现类，实现类的实例。 final 类型的变量一定要初始化 ， 因为final 的变量不可更改。 java 类是单继承 ，java 接口可以多继承。 static 方法只能使用 static 变量 ， 想使用非静态变量， 只能通过实例化对象 ，再通过对象引用 堆区 ： 只存放类对象 ， 线程共享 类中的成员变量， 存放在堆区 栈区 ： 存放局部变量，线程不共享 方法区 ： 静态存储区， 存放class文件 和静态数据。线程共享 静态语句块中变量为局部变量，不影响静态变量的值。 权限登记 ：public &gt; protected&gt; default&gt; private 在JDK1.7中，如果通过无参构造的话，初始数组容量为0（应该也是10），当真正对数组进行添加时，才真正分配容量。每次按照1.5倍（位运算）的比率通过copeOf的方式扩容。在JKD1.6中，如果通过无参构造的话，初始数组容量为10.每次通过copeOf的方式扩容后容量为原来的1.5倍加1.以上就是动态扩容的原理。1234567891011121314/**jdk8*/private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; jdk1.8后 关于arrayList 初始化和扩容详解 public:具有最大访问权限。 可以被同一项目下的任何类所调用，一般用于对外的情况。protected:与public不同的是不同包下的类是不能使用的，但是其子孙类除外。所以我认为这是特意为子类设计的。default:它是针对本包设计的，它所修饰的在本包下的其他类都访问。private:只为类本身提供。是一种封装的体现 A. 非抽象类继承抽象类，必须将抽象类中的方法重写，否则需将方法再次申明为抽象。所以这个方法还可再次声明为抽象，而不用重写。而用重载也错了，重载是在同一个类中，重写、覆盖才是在父子类中。B.抽象类可以没有抽象方法，接口是完全的抽象，只能出现抽象方法。C.抽象类无法实例化，无法创建对象。现实生活中也有抽象类的类子，比如说人类是一个抽象类，无法创建一个叫人类的对象，人继承人类来创建对象。况且抽象类中的抽象方法只有声明，没有主体，如果实例化了，又如何去实现调用呢？D因为类是单继承的，类继承了一个抽象类以后，就不能再继承其他类了。 静态方法是属于类的，当实例化该类时，静态会被优先加载并且只加载一次，不受实例化new 的影响，只要是使用了类，都会加载静态类。静态块只会执行一次。 鲁棒性(Robust,即健壮性)Java在编译和运行程序时，都要对可能出现的问题进行检查，以消除错误的产生。它提供自动垃圾收集来进行内存管理，防止程序员在管理内存时容易产生 的错误。通过集成的面向对象的例外处理机制，在编译时，Java揭示出可能出现但未被处理的例外，帮助程序员正确地进行选择以防止系统的崩溃。另外， Java在编译时还可捕获类型声明中的许多常见错误，防止动态运行时不匹配问题的出现。 Java中定义String数组，有两种定义方式：String a[]和String[] a byte能表示的范围[-128,127] 类的继承，自动向上转型 在定义方法参数时，通常总是应该优先使用父类或接口 对应成list ， 不需要定义多个对象 类里面只有属性和方法。 %取余操作，只适用于整型 如某个JAVA进程的JVM参数配置如下：-Xms1G -Xmx2G -Xmn500M -XX:MaxPermSize=64M -XX:+UseConcMarkSweepGC -XX:SurvivorRatio=3,请问eden区最终分配的大小是多少？java -Xmx2G -Xms1G -Xmn500M -Xss128k-Xmx2G：设置JVM最大可用内存为2G。-Xms1G：设置JVM促使内存为1G。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。-Xmn500M：设置年轻代大小为2G。整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小。-XX:SurvivorRatio=3:新生代中又会划分为 Eden 区，from Survivor、to Survivor 区。其中 Eden 和 Survivor 区的比例默认是 8:1:1，当然也支持参数调整 -XX:SurvivorRatio=3的话就是3:1:1。故该题为500*（1/3）=300M. interface中合法方法定义?()public void main(String [] args);没有关键字static，可以当成普通方法。 Iterator和 ListIterator主要区别 ListItertor有add()方法，可以向list中添加对象，而 iterator不能。 ListIterator 和 Iterator都有 hashNext()和 next()方法，可以实现顺序向后遍历。但是ListIterator 有 hasPrevious()和previous()方法，可以实现逆向遍历。Iterator就不可以 ListIterator 可以定位当前的索引位置，nextIndex() 和 previousIndex()可以实现。Iterator没有此功能。 都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iterator仅能遍历，不能修改。因为ListIterator的这些功能，可以实现对LinkedList等list数据结构的操作。 为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。包的作用 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。 如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。 Garbage Collection：当对象的所有引用都消失后，对象使用的内存将自动回收 cho $$ 当前登录shell 的PIDecho $? 最后运行的命令的结束代码（返回值）即执行上一个指令的返回值 (显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误) 接口中的属性在不提供修饰符修饰的情况下，会自动加上public static final注意（在1.8的编译器下可试）：（1）属性不能用private，protected,default 修饰，因为默认是public（2）如果属性是基本数据类型，需要赋初始值，若是引用类型，也需要初始化，因为默认有final修饰，必须赋初始值；（3）接口中常规的来说不能够定义方法体，所以无法通过get和set方法获取属性值，所以属性不属于对象，属于类（接口），因为默认使用static修饰。 start方法会开启一个新的线程执行run方法，所以start方法执行完，不代表run方法执行完，线程也不一定销毁！ 可以有方法名与类名相同的普通方法 “is”+100+5 在字符串后面的会自动转成字符串在字符串前面的不会转成字符串真题总结 内部类的访问规则 可以直接访问外部类的成员，包括私有 外部类要想访问内部类成员，必须创建对象 父子类中方法执行顺序 静态优先，普通代码块，构造随后 无论静态还是构造，先父再子 序列化：将数据转为n个byte序列的过程，也就是将数据结构转换称为二进制数据流或者文本流的过程。把对象转换为字节序列的过程，序列化后的数据方便在网络上传输和在硬盘上存储。反序列化：与序列化相反，是将二进制数据流或者文本流转换称为易于处理和阅读的数据结构的过程。这是java进程之间通信的方式。 按照流是否直接与特定的地方（如磁盘、内存、设备等）相连，分为节点流和处理流两类。 节点流：可以从或向一个特定的地方（节点）读写数据。如FileReader. 处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader.处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。 JAVA常用的节点流： 文 件 FileInputStream FileOutputStrean FileReader FileWriter 文件进行处理的节点流。 字符串 StringReader StringWriter 对字符串进行处理的节点流。 数 组 ByteArrayInputStream ByteArrayOutputStreamCharArrayReader CharArrayWriter 对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）。 管 道 PipedInputStream PipedOutputStream PipedReaderPipedWriter对管道进行处理的节点流。常用处理流（关闭处理流使用关闭里面的节点流）缓冲流：BufferedInputStrean BufferedOutputStream BufferedReader BufferedWriter 增加缓冲功能，避免频繁读写硬盘。转换流：InputStreamReader OutputStreamReader 实现字节流和字符流之间的转换。数据流 DataInputStream DataOutputStream 等-提供将基础数据类型写入到文件中，或者读取出来流的关闭顺序一般情况下是：先打开的后关闭，后打开的先关闭另一种情况：看依赖关系，如果流a依赖流b，应该先关闭流a，再关闭流b。例如，处理流a依赖节点流b，应该先关闭处理流a，再关闭节点流b可以只关闭处理流，不用关闭节点流。处理流关闭的时候，会调用其处理的节点流的关闭方法。 接口是更抽象的东西，属性默认是：public static final的，方法默认是public abstract的！ XML中DTD,XSD的区别DTD和XSD相比：DTD 是使用非 XML 语法编写的。DTD 不可扩展,不支持命名空间,只提供非常有限的数据类型 。DTD即文档类型定义，是一种XML约束模式语言，是XML文件的验证机制,属于XML文件组成的一部分。XML Schema语言也就是XSD。XML Schema描述了XML文档的结构。 JAVA中使用DOM方法解析XML文件XML现在已经成为一种通用的数据交换格式，平台的无关性使得很多场合都需要用到XML，DOM解析是将XML文件全部载入到内存，组装成一颗DOM树，然后通过节点以及节点之间的关系来解析XML文件。 多线程相关 调用run()，与调用start()的区别直接调用run()方法，并没有创建线程，跟调用普通方法是一样的。创建一个线程，需要覆盖Thread类的run（）方法，然后调用Thread类的start（）方法启动。Java集合体系Connection接口:— List 有序,可重复ArrayList优点: 底层数据结构是数组，查询快，增删慢。缺点: 线程不安全，效率高Vector优点: 底层数据结构是数组，查询快，增删慢。缺点: 线程安全，效率低LinkedList优点: 底层数据结构是链表，查询慢，增删快。缺点: 线程不安全，效率高 —Set 无序,唯一HashSet底层数据结构是哈希表。(无序,唯一)如何来保证元素唯一性?1.依赖两个方法：hashCode()和equals()LinkedHashSet底层数据结构是链表和哈希表。(FIFO插入有序,唯一)1.由链表保证元素有序2.由哈希表保证元素唯一TreeSet底层数据结构是红黑树。(唯一，有序) 如何保证元素排序的呢?自然排序比较器排序2.如何保证元素唯一性的呢?Map接口数据类型 基本数据类型包装类：包装类是对象，拥有方法和字段。 包装类型都是有重写equals方法初始值不同，int是0，boolean是false,包装类初始值是null,在定义javabean时，通常使用包装类，为防止数据库中有null数据。更例如定义List中，数据具体类型也是用包装类。 自动拆箱 包装类 ==》基本数据类型 int a = new Integer(100); [-128,127]在这个范围内，会直接从缓存(堆中的常量池)中取。 自动装箱 Double和BigDecimal123double d1 = 2.0;double d2 = 1.1;d1-d2 = 0.89999999; 实际运用中，在对金额的运算，通常使用的是BigDecimal。bigdecimal的equals方法，还会对数据中的小数点进行比较。通常使用compareTO方法比较大小。 {-1：小于， 0 ：等于， 1：大于}为了防止精度丢失，构造方法BigDecimal(“String”)来定义bigdecimal对象，禁止直接使用double。 类设计（jdk8新特性，接口中可以有方法） 接口默认是public,所有方法在接口中不能有实现（java8开始接口可以有默认实现 允许在接口中定义static方法和default方法（带方法体）） 接口本身可以通过extends关键字扩展多个接口 StringBuffer 和StringBuilder的区别 可变性 源码没有用final修饰，是可变的，String是final char[] ,不可变 线程安全性 StringBuilder非线程安全 性能 hashset 去重。HashSet ，通过重写teacher实体类中的eqauls和hashcode方法，定义去重原理。对list中存放对象，需重写equals方法和 list == null || list.size()==0 Date日期转换成指定格式的字符串日期。SimpleDataFormat是线程不安全的类，建议使用DateFormateUtils工具包// 日期String转DateDateUtils.parseDate(“2019-08-04”,”YYYY-MM-DD”) 代码规范 可以抽离代码 鼠标右击 》Refactor 》Extract]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习第四周]]></title>
    <url>%2F2019%2F07%2F25%2F%E5%AE%9E%E4%B9%A0%E7%AC%AC%E5%9B%9B%E5%91%A8%2F</url>
    <content type="text"><![CDATA[遗漏点 jpa技术 h2 database spring mvc @PathVariable method = RequestMethod.GET @ResponseStatus(HttpStatus.OK)返回状态码 @JsonIgnore作用：在json序列化时将java bean中的一些属性忽略掉，序列化和反序列化都受影响。使用方法：一般标记在属性或者方法上，返回的json数据即不包含该属性。 date parse()返回的是一个Date类型数据，format返回的是一个StringBuffer类型的数据 普通web项目右击项目，Project Structure -&gt; Artifacts -&gt; Output Layout，新建lib文件夹，将基于maven导入的jar包全部加进去，重新运行，顺利解决。 github记得.gitnore eclipse加上get/set shift+alt+s]]></content>
      <categories>
        <category>实习</category>
      </categories>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习第三周]]></title>
    <url>%2F2019%2F07%2F25%2F%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%91%A8%2F</url>
    <content type="text"><![CDATA[新增功能节点之后，给用户分配职责。 使用用户账号登录后，查看功能节点。 用户分配角色，分配职责。 参照设置 nc65sqlinsert into bd_refinfo (CODE, DR, ISNEEDPARA, ISSPECIALREF, LAYER, METADATANAMESPACE,METADATATYPENAME, MODULENAME, NAME, PARA1, PARA2, PARA3, PK_COUNTRY, PK_INDUSTRY, PK_REFINFO, REFCLASS, REFPATH, REFSYSTEM, REFTYPE, RESERV1, RESERV2, RESERV3, RESID, RESIDPATH, TS, WHEREPART)values (‘TR1010020’, 0, null, null, null, ‘uap’, ‘CustVo’, ‘uap’, ‘客户分类’, null, null, null, null, null,‘0001Z0100000002TRAIN’, ‘’, ‘nc.ui.train.pub.ref.CustClassRefModel’, null, 2, null, null, null, ‘客户分类’, ‘ref’,‘2019-05-29 13:44:08’, null);参照注意点：METADATATYPENAME：设置为空，对应的是实体的属性。 ORA-12541 数据库服务未监听服务管理员启动监听服务 –》lsnrctl start]]></content>
      <categories>
        <category>实习</category>
      </categories>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习第二周]]></title>
    <url>%2F2019%2F07%2F25%2F%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%91%A8%2F</url>
    <content type="text"><![CDATA[oracle数据库配置：在本地oracle环境中，tnsnames.ora文件中配置数据库信息。12345678910APPORCL(连接数据库的别名) = (DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = 115.28.**.**)(PORT = 1521)) ) (CONNECT_DATA = (SERVICE_NAME （数据库名）= corcl) )) nc63train/a 创建视图12345678910CREATE [OR REPLACE] [&#123;FORCE|NOFORCE&#125;] VIEW view_nameASSELECT查询[WITH READ ONLY CONSTRAINT]例子：create or REPLACE view p_rateASselect r.userid,r.rateset,p.usercode,p.username,p.alipayid from rate r,pro_user p where r.userid=p.userid; OR REPLACE：如果视图已经存在，则替换旧视图。 FORCE：即使基表不存在，也可以创建该视图，但是该视图不能正常使用，当基表创建成功后，视图才能正常使用。 NOFORCE：如果基表不存在，无法创建视图，该项是默认选项。 WITH READ ONLY：默认可以通过视图对基表执行增删改操作，但是有很多在基表上的限制(比如：基表中某列不能为空，但是该列没有出现在视图中，则不能通过视图执行insert操作)，WITH READ ONLY说明视图是只读视图，不能通过该视图进行增删改操作。现实开发中，基本上不通过视图对表中的数据进行增删改操作。删除视图可以使用“DROP VIEW 视图名称”，删除视图不会影响基表的数据。 全局数据库名称orcl管理口令 ilzzr888]]></content>
      <categories>
        <category>实习</category>
      </categories>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习第一周]]></title>
    <url>%2F2019%2F07%2F25%2F%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%91%A8%2F</url>
    <content type="text"><![CDATA[接触产品 erp nc65 中间件 UAP uap用友UAP平台是一体化平台，其中包括了开发平台、集成平台、动态建模平台、商业分析平台（用友BQ）、数据处理平台（用友AE）、云管理平台和运行平台等7个领域产品，这些平台产品涵盖了软件应用的全生命周期和IT服务管理过程，用于全面支撑平台化企业，可以为大中型企业与公共组织构建信息化平台提供核心工具与服务。账号密码 管理系统(用超级管理员打开)超级管理员root ilzzr888!! 系统管理员2 ilzzr888qwe（普通开启方式）集团管理员(失效日期设置，不对，还有奇怪)统一新增密码 ilzzr888用01 ilzzr888qwe职责里面没有分配功能一块 邮箱密码ilzzr888.. 用友云社区ilzzr888开发环境基础设置 窗口–&gt;首选项–&gt; java–&gt;jre 选用UAP自带的Runtime jre UAP-STUDIO–&gt;开发配置 UAP HOME设置，位置是uaphome 数据源等在配置基础环境sysconfig.bat脚本中就配置好，会自动导入 开发设置–&gt;客户端链接 端口号要与脚本设置一样。 oracle数据库nc65erp本地搭建UAP中间件搭建元数据建立与使用 新建实体组件 无业务组件[train.bill] 实体属性：创建实体时，访问器类型：当组件代码风格选择传统样式时，针对主子表或者多子表中主表对应的实体，访问器要设置为AggVO，即聚合VO访问器，其他的一律选择NCVO。 代码风格：自定义样式 向导生成单据属性 类型样式：SINGLE 单一样式，最终的类型就是原始数据类型。（与数据库对应，或者封装的类型。） REF:引用样式，用于实体，值对象，随后的类型即为参照。 主键一定设置为UFID类型。 字段名称即为生成数据库表列的名称。 对于设置为AggVO样式的实体，访问策略有设置为BodyOfAggVOAccessor. 参照设置：一个实体可以设置多个参照，但必须设置一个缺省参照。获取属性的参照时，如果没有设置则取属性对应实体的缺省参照。 树管理开发界面 与树卡档案不同的是，右边的信息只有一个字段与之关联，新增删除是对节点内容的修改。数据挂在节点下面。 树卡档案，树与卡片相联系，一个树节点就是一个卡片。增改卡片就是对树节点的修改。 整体开发流程： 元数据建模，节点注册配置，单击模板制作，输出模板制作，节点代码编写。 实现接口，记得配置接口属性映射（如何设置接口的属性。） 元数据发布：发布元数据，生成java源代码，生成建库sql脚本并执行。NC65学习记录 uap-studio新增模块后，需将模块信息注册到数据源。 生成元数据时，映射以及命名要规范。 orcl数据库安装管理口令： 创建模块之后，记得给登录系统管理员，给模块分配角色。]]></content>
      <categories>
        <category>实习</category>
      </categories>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql语句]]></title>
    <url>%2F2019%2F07%2F23%2Fsql%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[数据库分页limit 2，5从第三条开始，每次5条。 UNION去重且排序UNION ALL不去重不排序NION用的比较多union all是直接连接，取到得是所有值，记录可能有重复 union 是取唯一值，记录没有重复 UNION 的语法如下：[SQL 语句 1]UNION[SQL 语句 2] UNION ALL 的语法如下：[SQL 语句 1]UNION ALL[SQL 语句 2]UNION和UNION ALL关键字都是将两个结果集合并为一个]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zooKeeper]]></title>
    <url>%2F2019%2F07%2F18%2FzooKeeper%2F</url>
    <content type="text"><![CDATA[zookeeper服务启动在bin下启动服务 ： bin/zkServer.sh start 启动命令行 ： bin/zkCli.sh]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zookeeper小记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2019%2F07%2F16%2Fgit%2F</url>
    <content type="text"><![CDATA[git remote add &lt;主机名&gt; &lt;远程地址&gt; git remote -v 查看别称 git add . 添加所有 git reset 撤回所有add ,也可以针对特定文件。 git commit -m “提交说明” [git commit -a -m “ “] 组合命令，[-a] = git add . git push -u &lt;主机名&gt; master推送出错时，error: failed to push some refs to &#39;git@github.com:…..” 是因为没有将远程仓库同步，将远程仓库与本地代码合并。git pull –rebase origin mastergit pull origin master –allow-unrelated-histories git clone &lt;远程地址&gt; . 注意最后加 . 克隆当前目录 git diff #查看difference git reset]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git小记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax跨域]]></title>
    <url>%2F2019%2F07%2F05%2Fajax%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[为什么会发生跨域 浏览器限制（浏览器会对请求做校验，校验失败则是跨域。 ） 跨域 只要端口号，域名，协议..不同，浏览器都会将其标记为跨域 XHR(XMLHttpRequest)请求。如果不是XHR请求，浏览器也不会对其限制。解决思路 JSONP对json的补充，不是一个官方协议，但也是一个约定（前后台约定callback）。动态创建一个script标签，返回js代码（需要对后台代码做修改。）原理即是对发送的请求加一个callback参数，后台发现有callback参数，即知道是一个jsonp请求，就会将返回的数据将json改成JavaScript。JavaScript里的内容就是一个函数调用。dataType：”jsonp”,jsonp:”callback” 弊端： 服务器需要改动代码支持。 只支持get方法。 发送的不是XHR请求。（异步，各种事件的特性都无法使用） 支持跨域被调用方的角度。跨域请求是直接从浏览器发送过去的，在响应头中添加字段，告诉浏览器允许跨域。 服务器端实现 通过拦截器在响应头中添加字段 response.addHeader(“Access-Control-Allow-Origin”,”http://localhost:8081/*(允许所有方法)&quot;); 将这个字段设置为*，即为允许跨域，并不完善。 response.addHeader(“Access-Control-Allow-Methods”,”GET”); NGINX配置 APACHE配置 带cookie的跨域12345678910$.ajax(&#123; url : 'http://remote.domain.com/corsrequest', data : data, dataType: 'json', type : 'POST', xhrFields: &#123; withCredentials: true &#125;, crossDomain: true, contentType: "application/json", 通过设置 withCredentials: true ，发送Ajax时，Request header中便会带上 Cookie 信息。通过设置document里添加cookie 隐藏跨域在调用方的角度, 通过一个代理http服务器，将从A域名发出的请求，将指定的url加入B域名里面，就不会判定为跨域。静态请求：请求与用户数据无关。动态请求：请求与用户数据有关。]]></content>
      <categories>
        <category>跨域</category>
      </categories>
      <tags>
        <tag>小识跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习记录]]></title>
    <url>%2F2019%2F07%2F02%2F%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[在此记录实习过程中遇到的难点以及解决方案。]]></content>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java容器]]></title>
    <url>%2F2019%2F07%2F01%2Fjava%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[数组与链表的适用场景数组 优点具有快速查找特性。O(1)。 缺点在内存中地址是连续的，当需要扩容时，将会重新新建数组空间，拷贝旧数组的内容到新数组。每当删除，新增时，需要移动数组内容的位置。时间复杂度为O(N)。空间利用率低。适合多查，少增改链表 优点数据在内存中并不是连续的，当需要增改时，只需要改变指针位置。每一个结点都有一个指针域和数据域。 缺点遍历查找时麻烦，需要从头遍历查找。 容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql数据库]]></title>
    <url>%2F2019%2F06%2F18%2Fmysql%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[存储引擎mysql数据库引擎属于插件式存储引擎，基于业务可在不同的表上使用合适的存储引擎。在mysql5.5后，默认是InnoDB存储引擎。InnoDB：InnoDB是造成mysql灵活性的技术的直接产品。 支持事务处理，支持外键，行锁，当需要频繁的更新，删除操作时选择此引擎。MyISAM:不支持事务，支持表锁。读多写少可使用，查询效率更好。 更换存储引擎： Alter table XXX engine = InnoDB由于存储引擎不同，索引的结构也会相对不同。Myisam 的索引结构（非聚集索引）InnoDB表 （聚集索引） :即存数据又存索引 索引—–最常见的慢查询优化方式是一种优化查询的数据结构，mysql是基于B+树实现的，可以优化查询速度。 建索引原则：适合 ： 频繁作为where条件的字段。关联字段可以建索引，例如外键。 Order bt col, Group by col.不适合 ： where条件中用不到的字段，频繁更新的字段 ，数据值分布比较均匀的不适合建索引，例如男女 ， 真假值 ，表的数据量少]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复习小结]]></title>
    <url>%2F2019%2F06%2F18%2F%E5%A4%8D%E4%B9%A0%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[学习网站https://www.runoob.com/ bootstrap布局http://www.ibootstrap.cn 牛客备战网站https://www.nowcoder.com/studypath/1 整理复习 常忘小结（三门基本课程：数据结构，计算机网络，操作系统） 计算机网络 http协议 TCP三次握手，四次挥手 TCP滑动窗口机制Linux 常用命令 文件权限控制mysql数据库 两个常用存储引擎 数据库优化（sql优化，索引，水平垂直分表）JVM 对象的创建 垃圾回收java小结 java集合类大纲（全盘掌握） 基本数据类型对象的创建（spring,int）常忘 知识点小结框架小结 对于IOC，AOP的理解 spring MVC工作流程java java 容器]]></content>
      <categories>
        <category>复习</category>
      </categories>
      <tags>
        <tag>整理小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2F2019%2F06%2F18%2FHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[HTTP协议细讲 HTTP协议掌握考点 HTTP协议主要特点 HTTP报文的组成部分（请求报文，响应报文） get和post HTTP状态码主要特点 无连接 ：连接一次就会断开，不会继续保持连接 无状态客户端和服务器端是两种身份。第一次请求结束后，就断开了，第二次请求时，服务器端并没有记住之前的状态，也就是说，服务器端无法区分客户端是否为同一个人、同一个身份。有的时候，我们访问网站时，网站能记住我们的账号，这个是通过其他的手段（比如 session）做到的，并不是http协议能做到的。HTTP报文的组成部分 请求报文get/post请求方法 请求url http协议及版本号请求头 一堆键值对 请求体 name = tom &amp;password = 123(数据部分) 响应报文http协议/版本号 状态码及状态描述响应头响应体 返回信息记住组成部分，会考HTTP状态码http状态码响应类别共有5种：1XX ：指示信息，表示请求已接收，继续处理2XX ：处理成功3XX ：重定向，客户端应采取更多操作4XX : 客户端错误5XX : 服务器错误常见状态码200 OK :客户端请求成功204 ：没有资源返回206 ：范围请求，客户端只请求某个大文件里的一部分内容。比如说，如果播放视频地址或音频地址的前面一部分，可以用到206。301 ：永久性转移，请求的资源已被分配新的URl302 : 暂时性转移，本次使用这个304：我这个服务器告诉客户端，你已经有缓存了，不需要从我这里取了。400：请求报文存在错误403：权限不足404：找不到页面500：服务器发生错误，原来缓冲的文档还可以继续使用。503：服务器暂时无法处理请求，服务器临时过载或当机。一段时间后可能恢复正常。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo]]></title>
    <url>%2F2019%2F06%2F06%2Fhexo%2F</url>
    <content type="text"><![CDATA[hexo g 生成静态文件 generate hexo d 部署网站，需要预先生成静态文件 hexo clean 清楚缓存文件 hexo s 启动博客 hexo new “文章名称” 创建文章名称 hexo new page “tags” 新页面 组合命令 hexo d -g 部署上传 这是next主题优化网站 这是Typora官方网站]]></content>
      <categories>
        <category>hexo记录</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面经]]></title>
    <url>%2F2019%2F06%2F06%2F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[JavaGuide：JavaGuide，对于复习很有帮助，面试时候都会尽量刷一遍知识点。 云趣科技（凉）第一家面试的公司，准备不充分被刷。常规做笔试题（java基础应该掌握的东西）：数据库sql，多线程创建方式，适配器模式概述，代码重构的方法。面试：文件流操作，jsp隐藏属性，spring事务机制，jdbc如何实现，jdbc开启事务，jsp自定义标签，项目基本思路。总结：一定要尽早迈出第一步，尽早的查漏补缺，认识自己复习的到哪一步，有助于提升动力复习。 粤信科技（拿offer） 6.6面试距离第一次面试的公司，期间1个星期。重新整理复习的重点，掌握jvm，多线程，集合类，计网常用知识点等能够在面试中的加分项。笔试：java基础知识。面试：hr面和技术面自我介绍：也要准备好个稿，参考javaGuide。hr面：聊一下你在学校的生活，参加过什么活动。还有挑一个比较熟悉的项目讲给她听。这个感觉只要态度端正，要给面试官感觉到你尊重她，你在认真的听她讲话。这一部分暂不知道什么需要注意的。但排前一个的同学，就在这一面挂了，hr面完直接让他走了，没有技术面。技术面：全程都是根据你写的项目在问。所以一定要整理好自己项目的知识点。主要问题：挑一个你最熟悉的项目，说一说你是怎么设计数据库表的？你认为你这个项目中有哪个技术点让你印象深刻，你是怎么解决的？收到offer通知后，出错了。没能做保底，在hr跟我说需要实习到大四，嘴贱说初衷是打算实习3,4个月，然后换另一家公司。结果hr立马说那不行，收回入职邀请。她说我的心态已经变了，不会给考虑机会。555 用友科技（拿offer） 6.7没有笔试。面试：我看你简历上写了jvm,你说一下吧说一下java基础中，接口和抽象类的区别然后我自己在说知识点的时候，就提到自己的项目去了，最后两个项目都说了下业务逻辑，和一些基本的技术点。如果需要接触新知识，你是怎么学习的如果我要你在7天内完成任务，你完成不了，会怎么办你还要问我什么问题。（javaguide有提及，可以参考。）等了一周才发offer，公司大，环境好，但是工资较低，继续找 火烈鸟 6.11 凉透，难的发指。信心摧残。基础够格，就能过，无面经。]]></content>
      <categories>
        <category>面试汇总</category>
      </categories>
      <tags>
        <tag>面试总结</tag>
      </tags>
  </entry>
</search>
