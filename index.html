<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="ddd `Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="ddd `Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ddd `Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>ddd `Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ddd `Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">czt的博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/12/redis主从复制详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen ZeTao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/weixin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddd `Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/12/redis主从复制详解/" itemprop="url">redis主从复制详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-12T23:18:29+08:00">
                2019-10-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  10
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="旧版复制功能的实现"><a href="#旧版复制功能的实现" class="headerlink" title="旧版复制功能的实现"></a>旧版复制功能的实现</h3><p>Redis的复制功能分为同步（sync）和命令传播（command propagate）两个操作：</p>
<ul>
<li>同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态；</li>
<li>命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。</li>
</ul>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作，也即是，将从服务器的数据库状态更新至主服务器当前所处的数据库状态。</p>
<p>从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成，以下是SYNC命令的执行步骤：</p>
<ol>
<li>从服务器向主服务器发送SYNC命令；</li>
<li>收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令；</li>
<li>当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件，将自己的数据库状态更新至主服务器<strong>执行BGSAVE命令时的数据库状态</strong>。</li>
<li>主服务器将记录在缓冲区里面的所有写命令发送给从服务器，<strong>从服务器执行这些写命令</strong>，将自己的数据库状态更新至主服务器数据库当前所处的状态。</li>
</ol>
<h4 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h4><p>在执行完同步操作之后，主从服务器之间数据库状态已经相同了。但这个状态并非一成不变，如果主服务器执行了写操作，那么主服务器的数据库状态就会修改，并导致主从服务器状态不再一致。</p>
<p>所以为了让主从服务器再次回到一致状态，主服务器需要对从服务器执行命令传播操作：主服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态。</p>
<h3 id="旧版复制功能的缺陷"><a href="#旧版复制功能的缺陷" class="headerlink" title="旧版复制功能的缺陷"></a>旧版复制功能的缺陷</h3><p>在Redis中，从服务器对主服务器的复制可以分为以下两种情况：</p>
<ul>
<li>初次复制：从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同；</li>
<li>断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连接重新连上了主服务器，并继续复制主服务器。</li>
</ul>
<p>对于初次复制来说，旧版复制功能能够很好地完成任务，但对于断线后重复制来说，旧版复制功能虽然也能让主从服务器重新回到一致状态，但效率却非常低。</p>
<p>我们给出一个例子进行说明：</p>
<p><img src="https://images0.cnblogs.com/blog2015/754165/201508/071952224558416.png" alt="img"></p>
<p><img src="https://images0.cnblogs.com/blog2015/754165/201508/071952474555112.png" alt="img"></p>
<p>从服务器终于重新连接上主服务器，因为这时主从服务器的状态已经不再一致，所以从服务器将向主服务器发送SYNC命令，而主服务器会将包含键k1至键k10089的RDB文件发送给从服务器，从服务器通过接收和载入这个RDB文件来将自己的数据库更新至主服务器数据库当前所处的状态。</p>
<p>上面给出的例子可能有一点理想化，因为在主从服务器断线期间，主服务器执行的写命令可能会有成百上千个之多，而不仅仅是两三个写命令。但总的来说，主从服务器断开的时间越短，主服务器在断线期间执行的写命令就越少，而执行少量写命令所产生的数据量通常比整个数据库的数据量要少得多，在这种情况下，为了让从服务器补足一小部分缺失的数据，却要让主从服务器重新执行一次SYNC命令，这种做法无疑是非常低效的。</p>
<h4 id="SYNC命令是一个非常耗费资源的操作"><a href="#SYNC命令是一个非常耗费资源的操作" class="headerlink" title="SYNC命令是一个非常耗费资源的操作"></a>SYNC命令是一个非常耗费资源的操作</h4><p>SYNC命令是非常消耗资源的，因为每次执行SYNC命令，主从服务器需要执行一下操作：</p>
<ol>
<li>主服务器需要执行BGSAVE命令来生成RDB文件，这个生成操作会耗费主服务器大量的CPU、内存和磁盘I/O资源；</li>
<li>主服务器需要将自己生成的RDB文件发送给从服务器，这个发送操作会耗费主从服务器大量的网络资源（带宽和流量），并对主服务器响应命令请求的时间产生影响；</li>
<li>接收到RDB文件的从服务器需要载入主服务器发来的RDB文件，并且在载入期间，从<strong>服务器会因为阻塞而没办法处理命令请求</strong>。</li>
</ol>
<p>SYNC是一个如此消耗资源的命令，所以Redis最好在真需要的时候才需要执行SYNC命令。</p>
<h3 id="新版复制功能的实现"><a href="#新版复制功能的实现" class="headerlink" title="新版复制功能的实现"></a>新版复制功能的实现</h3><p>为了解决旧版复制功能在处理断线重复制情况时的低效问题，Redis从2.8版本开始，使用<strong>PSYNC</strong>命令代替SYNC命令来执行复制时的同步操作。</p>
<p>PSYNC命令具有完整重同步（full resynchronization）和部分重同步（partial resynchronization）两种模式：</p>
<ul>
<li>其中完整重同步用于处理初次复制情况：完整重同步的执行步骤和SYNC命令的执行步骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步；</li>
<li>而部分重同步则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，<strong>如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。</strong></li>
</ul>
<p>我们现在试举一例来看看使用PSYNC处理断线后情况：</p>
<p><img src="https://images0.cnblogs.com/blog2015/754165/201508/072019234716554.png" alt="img"></p>
<p><img src="https://images0.cnblogs.com/blog2015/754165/201508/072018554554146.png" alt="img"></p>
<p>下图展示了主从服务器在执行部分重同步时的通信过程。</p>
<p><img src="https://images0.cnblogs.com/blog2015/754165/201508/072022256438933.png" alt="img"></p>
<p>其实看到这里的时候心里还是有一个疑问的：如果上面的例子是T3时候从服务器掉线，然后在T10093的时候才连接上或者更长的时间呢！！！你这样一条指令一条指令地传输过去还不如直接来一个SYNC命令快一些。所以在我看来使用PSYNC进行操作时，什么时候部分重同步，什么时候全部重同步是一个策略问题。当然Redis会解决这个问题，所以大家继续看0_0</p>
<h3 id="部分重同步的实现"><a href="#部分重同步的实现" class="headerlink" title="部分重同步的实现"></a><strong>部分重同步的实现</strong></h3><p>部分重同步功能由以下三个部分构成：</p>
<ul>
<li>主服务器的<strong>复制偏移量</strong>（replication offset）和从服务器的复制偏移量；</li>
<li><strong>主服务器的复制积压缓冲区（replication backlog）</strong>；</li>
<li><strong>服务器的运行ID</strong>（run ID）。</li>
</ul>
<h4 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h4><p>执行复制的双方——主服务器和从服务器会分别维护一个复制偏移量：</p>
<ul>
<li>主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N；</li>
<li>从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N；</li>
</ul>
<p>（我靠！！难道从服务器没有反馈吗？丢包了怎么办？难道是用TCP？大家继续看，我只是想穿插一些我的思路）</p>
<p>通过对比主从服务器的复制偏移量，程序可以很容易地知道主从服务器是否处于一致状态：</p>
<ul>
<li>如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的；</li>
<li>相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态。</li>
</ul>
<p>如下面的情况：</p>
<p><img src="https://images0.cnblogs.com/blog2015/754165/201508/072056005964020.png" alt="img"></p>
<p>假设从服务器A在断线之后就立即重新连接主服务器，并且成功，那么接下来，<strong>从服务器将向主服务器发送PSYNC命令，报告从服务器A当前的复制偏移量为10086，</strong>那么这时，主服务器应该对从服务器执行完整重同步还是部分重同步呢？如果执行部分重同步的话，主服务器又如何补偿从服务器A在断线期间丢失的那部分数据呢？以上问题的答案都和复制积压缓冲区有关。</p>
<h4 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h4><p>复制积压缓冲区是由主服务器维护的一个固定长度（fixed-size）先进先出（FIFO）队列，默认大小为1MB。</p>
<p>和普通先进先出队列随着元素的增加和减少而动态调整长度不同，固定长度先进先出队列的长度是固定的，当入队元素的数量大于队列长度时，最先入队的元素会被弹出，而新元素会被放入队列。</p>
<p>当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面，如图所示。</p>
<p><img src="https://images0.cnblogs.com/blog2015/754165/201508/072109146748058.png" alt="img"></p>
<p>因此，主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量，就像下表所示的那样。</p>
<p><img src="https://images0.cnblogs.com/blog2015/754165/201508/072110329246085.png" alt="img"></p>
<p>当从服务器重新连上主服务器时，从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作：</p>
<ul>
<li>如果offset偏移量之后的数据（也即是偏移量offset+1开始的数据）仍然存在于复制积压缓冲区里面，那么主服务器将对从服务器执行部分重同步操作；</li>
<li>相反，如果offset偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器将对从服务器执行完整重同步操作。</li>
</ul>
<h4 id="根据需要调整复制积压缓冲区的大小"><a href="#根据需要调整复制积压缓冲区的大小" class="headerlink" title="根据需要调整复制积压缓冲区的大小"></a>根据需要调整复制积压缓冲区的大小</h4><p>Redis为复制积压缓冲区设置的默认大小为1MB，如果主服务器需要执行大量写命令，又或者主从服务器断线后重连接所需的时间比较长，那么这个大小也许并不合适。如果复制积压缓冲区的大小设置得不恰当，那么PSYNC命令的复制重同步模式就不能正常发挥作用，因此，正确估算和设置复制积压缓冲区的大小非常重要。<br>复制积压缓冲区的最小大小可以根据公式second*write_size_per_second来估算：</p>
<ul>
<li>其中second为从服务器断线后重新连接上主服务器所需的平均时间（以秒计算）；</li>
<li>而write_size_per_second则是主服务器平均每秒产生的写命令数据量（协议格式的写命令的长度总和）；</li>
</ul>
<p>例如，如果主服务器平均每秒产生1 MB的写数据，而从服务器断线之后平均要5秒才能重新连接上主服务器，那么复制积压缓冲区的大小就不能低于5MB。<br>为了安全起见，可以将复<strong>制积压缓冲区的大小设为2*second*write_size_per_second</strong>，这样可以保证绝大部分断线情况都能用部分重同步来处理。<br>至于复制积压缓冲区大小的修改方法，可以参考配置文件中关于<strong>repl-backlog-size</strong>选项的说明。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/12/count-1-count-count-col/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen ZeTao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/weixin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddd `Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/12/count-1-count-count-col/" itemprop="url">count(1),count(*),count(col)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-12T21:55:17+08:00">
                2019-10-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  231
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="count-1-and-count"><a href="#count-1-and-count" class="headerlink" title="count(1) and count(*)"></a>count(1) and count(*)</h3><p>当表的数据量大些时，对表作分析之后，使用count(1)还要比使用count(<em>)用时多了！<br>从执行计划来看，count(1)和count(</em>)的效果是一样的。 但是在表做过分析之后，count(1)会比count(*)的用时少些（1w以内数据量），不过差不了多少。 </p>
<p>如果count(1)是聚索引,id,那肯定是count(1)快。但是差的很小的。<br>因为count(<em>),自动会优化指定到那一个字段。所以没必要去count(1)，用count(</em>)，sql会帮你完成优化的 因此：count(1)和count(*)基本没有差别！ </p>
<h3 id="count-1-and-count-字段"><a href="#count-1-and-count-字段" class="headerlink" title="count(1) and count(字段)"></a>count(1) and count(字段)</h3><p>两者的主要区别是<br>（1） count(1) 会统计表中的所有的记录数，包含字段为null 的记录。<br>（2） count(字段) 会统计该字段在表中出现的次数，忽略字段为null 的情况。即不统计字段为null 的记录。 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/10/简历坑/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen ZeTao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/weixin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddd `Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/10/简历坑/" itemprop="url">简历坑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-10T10:03:33+08:00">
                2019-10-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  8
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="为什么用MongoDB"><a href="#为什么用MongoDB" class="headerlink" title="为什么用MongoDB"></a>为什么用MongoDB</h2><p>Mongodb是以文档的形式存储数据的，他的风格比较类似于JSON。文档类似于编程语言中的键和值的方式联系在一起的。严格意义来讲，MongoDB文档是BSON文档。BSON文档是带有附加类型信息的二进制JSON文档。在文档里，字段的值可以是任何BSON数据类型，他们可以是其他的文档，数组，和数组文档。</p>
<ol>
<li>MongoDB主要拿来储存学生的信息数据，格式比较灵活，不用为了各种格式不一样的信息专门设计统一的格式。小程序与后台交互都是通过json进行。</li>
<li>相比于其他数据库，使用MongoDB通常能以更低的成本解决问题，（包括学习，开发，运维等成本）</li>
<li>因为存储的是信息数据，主要是读，没有复杂的事务场景，MongoDB也只支持单文档的事务，符合要求。</li>
</ol>
<h2 id="实习业务逻辑"><a href="#实习业务逻辑" class="headerlink" title="实习业务逻辑"></a>实习业务逻辑</h2><p>接口对接：</p>
<p>数据验证：将数据体通过sha1算法加密生成数据签名，接收方通过一样的方式，将数据进行加密，判断两者的数据签名是否一致，以此判断数据的一致性。</p>
<p>主要是一个审批流的逻辑，当员工在ERP中提交一个需要报销的发票，需要主管审批，那么会在nc中填好对应的信息，并通过对接接口发送信息到公司的OA，通知公司主管进入到nc的web端进行审批。</p>
<p>在接口的调用中，会对接口中的数据根据业务需求做VO上面的转换</p>
<p><strong>SHA1算法简介</strong></p>
<p>安全哈希算法（Secure Hash Algorithm）主要适用于数字签名标准（Digital Signature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA）。对于长度小于2^64位的消息，SHA1会产生一个160位的消息摘要。当接收到消息的时候，这个消息摘要可以用来验证数据的完整性。在传输的过程中，数据很可能会发生变化，那么这时候就会产生不同的消息摘要。</p>
<p>SHA1有如下特性：不可以从消息摘要中复原信息；两个不同的消息不会产生同样的消息摘要。</p>
<h2 id="Docker原理"><a href="#Docker原理" class="headerlink" title="Docker原理"></a>Docker原理</h2><p>Docker的思想来自于集装箱，集装箱解决了什么问题？在一艘大船上，可以把货物规整的摆放起来。并且各种各样的货物被集装箱标准化了，集装箱和集装箱之间不会互相影响。那么我就不需要专门运送水果的船和专门运送化学品的船了。只要这些货物在集装箱里封装的好好的，那我就可以用一艘大船把他们都运走。</p>
<p>Docker 是一个<strong>便携的应用容器</strong></p>
<h3 id="避免“我机器上可以运行”"><a href="#避免“我机器上可以运行”" class="headerlink" title="避免“我机器上可以运行”"></a>避免“我机器上可以运行”</h3><p>无论是上一篇介绍的企业部署 Docker 还是本文的个人 Docker 用例，都提到了这个情况。因为环境配置不同，很多人在开发中也会遇到这个情况，甚至开发的软件到了测试人员的机器上便不能运行。但这都不是重点。重点是，如果我们有一个可靠的、可分发的标准开发环境，那么我们的开发将不会像现在这么痛苦。Docker 便可以解决这个问题。Docker 镜像并不会因为环境的变化而不能运行，也不会在不同的电脑上有不同的运行结果。可以给测试人员提交含有应用的 Docker 镜像，这样便不再会发生“在我机器上是可以运行的”这种事情，很大程度上减轻了开发人员测试人员互相检查机器环境设置带来的时间成本。<br>另一个 Docker 可以发挥用处的地方是培训班。除了 Docker 容器的隔离性之外，更能体会到 Docker 优势的地方在于环境搭建。培训班的新手每个人都要在环境搭建上花费很多时间，但是如果在这里应用到 Docker 的话，那么我们只需要把标准的运行环境镜像分发下去，然后就可以开始上课了。使用 Docker 和使用虚拟机一样简单，但是 Docker 要更方便、更轻量级。同时，我们也可以告诉学员：“在培训的同时，我们还将学到当下最流行的技术——Docker”，这种双赢的结局，何乐而不为呢。</p>
<h3 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h3><p>Docker 包括三个基本概念</p>
<ul>
<li><strong>镜像（Image）</strong></li>
<li><strong>容器（Container）</strong></li>
<li><strong>仓库（Repository）</strong></li>
</ul>
<p>理解了这三个概念，就理解了 Docker 的整个生命周期</p>
<h4 id="镜像-Image-一个特殊的文件系统"><a href="#镜像-Image-一个特殊的文件系统" class="headerlink" title="镜像(Image):一个特殊的文件系统"></a>镜像(Image):一个特殊的文件系统</h4><p>　　<strong>操作系统分为内核和用户空间</strong>。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而Docker 镜像（Image），就相当于是一个 root 文件系统。</p>
<p>　　<strong>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</strong> 镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<p>　　Docker 设计时，就充分利用 <strong>Union FS</strong>的技术，将其设计为 <strong>分层存储的架构</strong> 。 镜像实际是由多层文件系统联合组成。</p>
<p>　　<strong>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</strong>　比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>
<p>　　分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<h4 id="容器-Container）"><a href="#容器-Container）" class="headerlink" title="容器(Container）"></a>容器(Container）</h4><p>　　镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，<strong>容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等</strong> 。</p>
<p>　　<strong>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。前面讲过镜像使用的是分层存储，容器也是如此。</strong></p>
<p>　　<strong>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</strong></p>
<p>　　按照 Docker 最佳实践的要求，<strong>容器不应该向其存储层内写入任何数据</strong> ，容器存储层要保持无状态化。<strong>所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录</strong>，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此， <strong>使用数据卷后，容器可以随意删除、重新 run ，数据却不会丢失。</strong></p>
<h4 id="仓库-Repository"><a href="#仓库-Repository" class="headerlink" title="仓库(Repository)"></a>仓库(Repository)</h4><p>　　镜像构建完成后，可以很容易的在当前宿主上运行，但是， <strong>如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。</strong></p>
<p>　　一个 Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。所以说：<strong>镜像仓库是Docker用来集中存放镜像文件的地方类似于我们之前常用的代码仓库。</strong></p>
<p>　　通常，<strong>一个仓库会包含同一个软件不同版本的镜像</strong>，而<strong>标签就常用于对应该软件的各个版本</strong> 。我们可以通过<code>&lt;仓库名&gt;:&lt;标签&gt;</code>的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签.。</p>
<p><strong>这里补充一下Docker Registry 公开服务和私有 Docker Registry的概念：</strong></p>
<p>　　<strong>Docker Registry 公开服务</strong> 是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p>
<p>　　最常使用的 Registry 公开服务是官方的 <strong>Docker Hub</strong> ，这也是默认的 Registry，并拥有大量的高质量的官方镜像，网址为：<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a> 。在国内访问<strong>Docker Hub</strong> 可能会比较慢国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://hub.tenxcloud.com/" target="_blank" rel="noopener">时速云镜像库</a>、<a href="https://www.163yun.com/product/repo" target="_blank" rel="noopener">网易云镜像服务</a>、<a href="https://www.daocloud.io/" target="_blank" rel="noopener">DaoCloud 镜像市场</a>、<a href="https://www.aliyun.com/product/containerservice?utm_content=se_1292836" target="_blank" rel="noopener">阿里云镜像库</a>等。</p>
<p>　　除了使用公开服务外，用户还可以在 <strong>本地搭建私有 Docker Registry</strong> 。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。zhen </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/09/mysql慢查询配置/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen ZeTao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/weixin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddd `Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/09/mysql慢查询配置/" itemprop="url">mysql慢查询配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-09T10:10:17+08:00">
                2019-10-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  10
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第一步-开启-MySQL-慢查询"><a href="#第一步-开启-MySQL-慢查询" class="headerlink" title="第一步.开启 MySQL 慢查询"></a>第一步.开启 MySQL 慢查询</h2><h3 id="方式一、修改配置文件"><a href="#方式一、修改配置文件" class="headerlink" title="方式一、修改配置文件"></a>方式一、修改配置文件</h3><p>Windows：配置文件为 my.ini，一般在 MySQL 安装目录下或者 c:\Windows 下。<br>Linux：配置文件为 my.cnf ，一般在 /etc 下。<br>在 my.ini 增加下面代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]  </span><br><span class="line">long_query_time=<span class="number">2</span>  </span><br><span class="line"></span><br><span class="line">#<span class="number">5.5</span>以前版本配置如下选项  </span><br><span class="line"><span class="built_in">log</span>-slow-queries=<span class="string">"mysql_slow_query.log"</span>  </span><br><span class="line">#<span class="number">5.5</span>及以上版本配置如下选项  </span><br><span class="line">slow-query-<span class="built_in">log</span>=On  </span><br><span class="line">slow_query_log_file=<span class="string">"mysql_slow_query.log"</span>  </span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>-query-<span class="keyword">not</span>-<span class="keyword">using</span>-indexes</span><br></pre></td></tr></table></figure>
<p>第一句：定义超过多少秒的查询算是慢查询，这里定义的是2秒<br>第二句：定义慢查询日志的路径（注意如果是 Linux 或 Mac 系统要考虑权限问题）<br>第三句：记录下没有使用索引的query</p>
<h3 id="方式二、通过命令行开启慢查询"><a href="#方式二、通过命令行开启慢查询" class="headerlink" title="方式二、通过命令行开启慢查询"></a>方式二、通过命令行开启慢查询</h3><p>上面的配置需要重启 mysql server 进程 mysqld 才会生效。但很多时候，尤其是产品生产环境，不希望每次修改都要重新启动mysql服务器，而是希望能在某些特定时间记录。MySQL5.1 之后为我们提供了灵活的运行时控制，使得你不必重新启动 mysql 服务器，也能选择性地记录或不记录某些 slow queries。</p>
<p>MySQL5.1中，提供了全局变量 slow_query_log、slow_query_log_file，可以灵活地控制enable/disable慢查询。同时可以通过 long_query_time 设置慢查询时间</p>
<p><strong>注意:设置了全局变量 slow_query_log ,则变量 log_slow_queries 也会隐性地跟着改变</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;<span class="keyword">set</span> <span class="keyword">global</span> slow_query_log=ON</span><br></pre></td></tr></table></figure>
<p>不幸的是,在 MySQL5.1 之前并没有提供类似的全局变量来灵活控制，但是我们可以通过将long_query_time 设置得足够大来避免记录某些查询语句。比如</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;<span class="keyword">set</span> <span class="keyword">global</span> long_query_time = <span class="number">3600</span>;</span><br><span class="line">mysql&gt;<span class="keyword">set</span> <span class="keyword">global</span> log_querise_not_using_indexes = ON;</span><br></pre></td></tr></table></figure>
<p>MySQL5.0 在不关闭服务的情况下，希望不记录日志的办法是让日志文件成为 /dev/null 的符号链接(symbolic link)。注意:你只需要在改变后运行 flush logs 以确定MySQL释放当前的日志文件描述符，重新把日志记录到/dev/null。</p>
<p>和 MySQL5.0 不同, MySQL5.1 后可以在运行时改变日记行为，将日志记录到数据库表中。只要将 MySQL 全局变量 log_output 设置为 table 即可。MySQL 会将日志分别记录到mysql.gengera_log 和 mysql.slow_log 两张表中。但是，推荐的做法是将日志记录在日记文件中。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like ‘log_output’\G</span><br><span class="line">Variable_name: log_output</span><br><span class="line">Value: FILE</span><br><span class="line">mysql&gt;<span class="keyword">set</span> <span class="keyword">global</span> log_output=’table’;</span><br></pre></td></tr></table></figure>
<p><strong>缺陷与审记</strong><br>如果开启了 log_queries_not_using_indexes 选项，slow query 日志会充满过多的垃圾日志记录，这些快且高效的全表扫描查询(表小)会冲掉真正有用的slow queries记录。比如 select * from category 这样的查询也会被记录下来。<br>通过microslow-patch补丁可使用更细的时间粒度，和记录所有执行过的sql语句。不过，使用这个补订不得不自己编译MySQL，出于稳定性考滤，我们推荐在开发测试环境，可以打上这个补丁，享受这个补丁带来的便利。在运营环境尽量不要这么做…</p>
<h2 id="第五步-分析慢查询日志"><a href="#第五步-分析慢查询日志" class="headerlink" title="第五步.分析慢查询日志"></a>第五步.分析慢查询日志</h2><h3 id="方式一-通过工具分析"><a href="#方式一-通过工具分析" class="headerlink" title="方式一.通过工具分析"></a>方式一.通过工具分析</h3><p>MySQL 自带了 mysqldumpslow 工具用来分析 slow query 日志，除此之外，还有一些好用的开源工具。比如<a href="https://link.jianshu.com/?t=http://sourceforge.net/projects/myprofi/" target="_blank" rel="noopener">MyProfi</a>、mysql-log-filter，当然还有 mysqlsla。</p>
<p>以下是 mysqldumpslow 常用参数说明，详细内容可用 mysqldumpslow -help 查询。<br>-s，表示按照何种方式排序，c、t、l、r分别是按照记录次数、时间、查询时间、返回的记录数来排序（从大到小），ac、at、al、ar表示相应的倒序。<br>-t，是top n的意思，即为返回前面多少条数据。<br>-g，后边可以写一个正则匹配模式，大小写不敏感。</p>
<p>接下来就是用MySQL 自带的慢查询工具 mysqldumpslow 分析了（该工具位于 MySQL 的bin 目录下），我这里的日志文件名字是host-slow.log。</p>
<p>列出记录次数最多的10个sql语句</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow -s c -t <span class="number">10</span> host-slow.<span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<p>列出返回记录集最多的10个sql语句</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow -s r -t <span class="number">10</span> host-slow.<span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><p><strong>6 keys</strong> MYSQL使用的索引，简单且重要</p>
<p><strong>7 key_len</strong> MYSQL使用的索引长度</p>
<p><strong>8 ref</strong>   ref列显示使用哪个列或常数与key一起从表中选择行。</p>
<p><strong>9 rows</strong> 显示MYSQL执行查询的行数，简单且重要，数值越大越不好，说明没有用好索引</p>
<p>在日常工作中，我们会有时会开慢查询去记录一些执行时间比较久的SQL语句，找出这些SQL语句并不意味着完事了，些时我们常常用到explain这个命令来查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上了索引，有没有做全表扫描，这都可以通过explain命令来查看。所以我们深入了解MySQL的基于开销的优化器，还可以获得很多可能被优化器考虑到的访问策略的细节，以及当运行SQL语句时哪种策略预计会被优化器采用。（QEP：sql生成一个执行计划query Execution plan）</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from servers;</span><br><span class="line">+----+-------------+---------+------+---------------+------+---------+------+------+-------+</span><br><span class="line">| id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | Extra |</span><br><span class="line">+----+-------------+---------+------+---------------+------+---------+------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | servers | ALL  | NULL          | NULL | NULL    | NULL |    1 | NULL  |</span><br><span class="line">+----+-------------+---------+------+---------------+------+---------+------+------+-------+</span><br><span class="line">1 row in set (0.03 sec)</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>expain出来的信息有10列，分别是id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra,下面对这些字段出现的可能进行解释：</p>
<p>一、 <strong>id</strong></p>
<p>​     <strong>我的理解是SQL执行的顺序的标识,SQL从大到小的执行</strong></p>
<p>\1. id相同时，执行顺序由上至下</p>
<p>\2. 如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p>
<p>3.id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</p>
<p><strong>二、select_type</strong></p>
<p>​      <strong>示查询中每个select子句的类型</strong></p>
<p>(1) SIMPLE(简单SELECT,不使用UNION或子查询等)</p>
<p>(2) PRIMARY(查询中若包含任何复杂的子部分,最外层的select被标记为PRIMARY)</p>
<p>(3) UNION(UNION中的第二个或后面的SELECT语句)</p>
<p>(4) DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)</p>
<p>(5) UNION RESULT(UNION的结果)</p>
<p>(6) SUBQUERY(子查询中的第一个SELECT)</p>
<p>(7) DEPENDENT SUBQUERY(子查询中的第一个SELECT，取决于外面的查询)</p>
<p>(8) DERIVED(派生表的SELECT, FROM子句的子查询)</p>
<p>(9) UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)</p>
<p><strong>三、table</strong></p>
<p>显示这一行的数据是关于哪张表的，有时不是真实的表名字,看到的是derivedx(x是个数字,我的理解是第几步执行的结果)</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from (select * from ( select * from t1 where id=2602) a) b;</span><br><span class="line">+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+</span><br><span class="line">| id | select_type | table      | type   | possible_keys     | key     | key_len | ref  | rows | Extra |</span><br><span class="line">+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+</span><br><span class="line">|  1 | PRIMARY     | &lt;derived2&gt; | system | NULL              | NULL    | NULL    | NULL |    1 |       |</span><br><span class="line">|  2 | DERIVED     | &lt;derived3&gt; | system | NULL              | NULL    | NULL    | NULL |    1 |       |</span><br><span class="line">|  3 | DERIVED     | t1         | const  | PRIMARY,idx_t1_id | PRIMARY | 4       |      |    1 |       |</span><br><span class="line">+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p><strong>四、type</strong></p>
<p>表示MySQL在表中找到所需行的方式，又称“访问类型”。</p>
<p>常用的类型有： <strong>ALL, index,  range, ref, eq_ref, const, system, NULL（从左到右，性能从差到好）</strong></p>
<p>ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行</p>
<p>index: Full Index Scan，index与ALL区别为index类型只遍历索引树</p>
<p>range:只检索给定范围的行，使用一个索引来选择行</p>
<p>ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p>
<p>eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件</p>
<p>const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量,system是const类型的特例，当查询的表只有一行的情况下，使用system</p>
<p>NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</p>
<p><strong>五、possible_keys</strong></p>
<p><strong>指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用</strong></p>
<p>该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。<br>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询</p>
<p><strong>六、Key</strong></p>
<p><strong>key列显示MySQL实际决定使用的键（索引）</strong></p>
<p>如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。</p>
<p><strong>七、key_len</strong></p>
<p><strong>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）</strong></p>
<p>不损失精确性的情况下，长度越短越好 </p>
<p><strong>八、ref</strong></p>
<p><strong>表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</strong></p>
<p><strong>九、rows</strong></p>
<p> <strong>表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</strong></p>
<p><strong>十、Extra</strong></p>
<p><strong>该列包含MySQL解决查询的详细信息,有以下几种情况：</strong></p>
<p>Using where:列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤</p>
<p>Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询</p>
<p>Using filesort：MySQL中无法利用索引完成的排序操作称为“文件排序”</p>
<p>Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。</p>
<p>Impossible where：这个值强调了where语句会导致没有符合条件的行。</p>
<p>Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行</p>
<p><strong>总结： EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况• EXPLAIN不考虑各种Cache• EXPLAIN不能显示MySQL在执行查询时所作的优化工作• 部分统计信息是估算的，并非精确值• EXPALIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/08/nginx解答/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen ZeTao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/weixin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddd `Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/08/nginx解答/" itemprop="url">nginx解答</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-08T23:52:31+08:00">
                2019-10-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>  正向代理是一个位于客户端和目标服务器之间的代理服务器(中间服务器)。为了从原始服务器取得内容，客户端向代理服务器发送一个请求，并且指定目标服务器，之后代理向目标服务器转交并且将获得的内容返回给客户端。正向代理的情况下客户端必须要进行一些特别的设置才能使用。</p>
<p>  反向代理正好相反。对于客户端来说，反向代理就好像目标服务器。并且客户端不需要进行任何设置。客户端向反向代理发送请求，接着反向代理判断请求走向何处，并将请求转交给客户端，使得这些内容就好似他自己一样，一次客户端并不会感知到反向代理后面的服务，也因此不需要客户端做任何设置，只需要把反向代理服务器当成真正的服务器就好了。</p>
<h3 id="2-区别"><a href="#2-区别" class="headerlink" title="2. 区别"></a>2. 区别</h3><p>  正向代理需要你主动设置代理服务器ip或者域名进行访问，由设置的服务器ip或者域名去获取访问内容并返回；而反向代理不需要你做任何设置，直接访问服务器真实ip或者域名，但是服务器内部会自动根据访问内容进行跳转及内容返回，你不知道它最终访问的是哪些机器。</p>
<p>  正向代理是代理客户端，为客户端收发请求，使真实客户端对服务器不可见；而反向代理是代理服务器端，为服务器收发请求，使真实服务器对客户端不可见。</p>
<p>2、安装tomcat2个,现在我们模拟的话服务器就采用tomcat来模拟。</p>
<p>安装tomcat的过程就不介绍了，在<a href="http://blog.csdn.net/u013144287/article/details/78499485过程中有介绍，" target="_blank" rel="noopener">http://blog.csdn.net/u013144287/article/details/78499485过程中有介绍，</a><br>（1）创建一个tomcat目录mkdir -p /usr/local/tomcats<br>在此目录下安装两个tomcat如图所示：</p>
<p>（2）修改tomcat2的端口号，vi ./tomcat2/conf/server.xml</p>
<p><server port="8006" shutdown="SHUTDOWN"></server></p>
<p><connector port="8081" protocol="HTTP/1.1" connectiontimeout="20000" redirectport="8443"></connector></p>
<p><connector port="8010" protocol="AJP/1.3" redirectport="8443"><br>修改此3处端口号，分别在原来基础上加1，然后wq保存，启动两台tomcat</connector></p>
<p>3、需求<br>nginx的安装可以参考<a href="http://blog.csdn.net/u013144287/article/details/78408001此篇文章" target="_blank" rel="noopener">http://blog.csdn.net/u013144287/article/details/78408001此篇文章</a><br>通过访问不同的域名访问运行在tomcat不同端口的服务器，中间使用nginx反向代理服务器<br>windows上访问需要修改hosts文件进行配置如下：<br>8080.zcinfo.com 访问运行8080端口的tomcat</p>
<p>8082.zcinfo.com 访问运行8081端口的tomcat</p>
<p>如图所示：hosts目录是：C:\Windows\System32\drivers\etc</p>
<p>4、Nginx的配置<br>在Nginx的配置文件里面加入如下配置<br>   upstream tomcatserver1 {<br>    server 192.168.3.43:8080;<br>    }<br>    upstream tomcatserver2 {<br>    server 192.168.3.43:8082;<br>    }<br>   server {<br>        listen       80;<br>        server_name  8080.zcinfo.com;</p>
<pre><code>    #charset koi8-r;

    #access_log  logs/host.access.log  main;

    location / {
        proxy_pass   http://tomcatserver1;
        index  index.html index.htm;
    }  
}
server {
    listen       80;
    server_name  8082.zcinfo.com;

    #charset koi8-r;

    #access_log  logs/host.access.log  main;

    location / {
        proxy_pass   http://tomcatserver2;
        index  index.html index.htm;
    }
}
</code></pre><p>重启nginx<br>ps：如果在同一个域名下有多台服务器提供服务，此时需要nginx负载均衡。<br>5、测试</p>
<p>至此恭喜您，nginx反向代理成功<br>二、负载均衡<br>1、什么是负载均衡？<br>负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。</p>
<p>负载均衡，英文名称为Load Balance，其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。</p>
<p>2、需求</p>
<p>nginx作为负载均衡服务器，用户请求先到达nginx，再由nginx根据负载配置将请求转发至tomcat服务器。</p>
<p>nginx负载均衡服务器：192.168.3.43</p>
<p>tomcat1服务器：192.168.3.43:8080</p>
<p>tomcat2服务器：192.168.3.43:8081</p>
<p>3、nginx的配置</p>
<p>  upstream tomcatserver1 {<br>    server 192.168.3.43:8080;<br>        server 192.168.3.43:8082; #多加了此台服务器<br> }<br>    upstream tomcatserver2 {<br>    server 192.168.3.43:8082;<br>    }<br>   server {<br>        listen       80;<br>        server_name  8080.zcinfo.com;</p>
<pre><code>    #charset koi8-r;

    #access_log  logs/host.access.log  main;

    location / {
        proxy_pass   http://tomcatserver1;
        index  index.html index.htm;
    }  
}
server {
    listen       80;
    server_name  8082.zcinfo.com;

    #charset koi8-r;

    #access_log  logs/host.access.log  main;

    location / {
        proxy_pass   http://tomcatserver2;
        index  index.html index.htm;
    }
}
</code></pre><p>如果两台服务器性能差不多这样设置重启nginx就行了，但是现在假如两台服务器性能不一样，还需要设置性能权重，让性能高服务器做更多事情。只需要加入weight=?就行了，如下：</p>
<p>upstream tomcatserver1 {<br>    server 192.168.3.43:8080 weight=2;<br>        server 192.168.3.43:8082 weight=1;<br> }<br>    upstream tomcatserver2 {<br>    server 192.168.3.43:8082;<br>    }<br>   server {<br>        listen       80;<br>        server_name  8080.zcinfo.com;</p>
<pre><code>    #charset koi8-r;

    #access_log  logs/host.access.log  main;

    location / {
        proxy_pass   http://tomcatserver1;
        index  index.html index.htm;
    }  
}
server {
    listen       80;
    server_name  8082.zcinfo.com;

    #charset koi8-r;

    #access_log  logs/host.access.log  main;

    location / {
        proxy_pass   http://tomcatserver2;
        index  index.html index.htm;
    }
}
</code></pre><p>重新启动nginx,会发现8080出现了两次，8082出现一次这样轮循。<br>ps:关于nginx负载均衡的一些参数介绍例子</p>
<p>节点说明：<br>在http节点里添加:</p>
<p>#定义负载均衡设备的 Ip及设备状态<br>upstream myServer {   </p>
<pre><code>server 127.0.0.1:9090 down; 
server 127.0.0.1:8080 weight=2; 
server 127.0.0.1:6060; 
server 127.0.0.1:7070 backup; 
</code></pre><p>}</p>
<p>在需要使用负载的Server节点下添加</p>
<p>proxy_pass <a href="http://myServer" target="_blank" rel="noopener">http://myServer</a>;</p>
<p>upstream 每个设备的状态:</p>
<p>down 表示单前的server暂时不参与负载<br>weight  默认为1.weight越大，负载的权重就越大。<br>max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误<br>fail_timeout:max_fails 次失败后，暂停的时间。<br>backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</p>
<p>4、效果</p>
<p>————————————————<br>版权声明：本文为CSDN博主「演员赵诗绎」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/u013144287/article/details/78551398" target="_blank" rel="noopener">https://blog.csdn.net/u013144287/article/details/78551398</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/07/分布式锁实现对比/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen ZeTao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/weixin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddd `Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/07/分布式锁实现对比/" itemprop="url">分布式锁实现对比</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-07T23:21:01+08:00">
                2019-10-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  609
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="分布式情况下，怎么解决订单号生成不重复"><a href="#分布式情况下，怎么解决订单号生成不重复" class="headerlink" title="分布式情况下，怎么解决订单号生成不重复"></a>分布式情况下，怎么解决订单号生成不重复</h2><ol>
<li>使用分布式锁</li>
<li>提前生成好，订单号，存放在redis取。获取订单号，直接从redis中取。</li>
</ol>
<h2 id="使用分布式锁生成订单号技术"><a href="#使用分布式锁生成订单号技术" class="headerlink" title="使用分布式锁生成订单号技术"></a>使用分布式锁生成订单号技术</h2><p>1.使用数据库实现分布式锁</p>
<p>缺点:性能差、线程出现异常时，容易出现死锁</p>
<p>2.使用redis实现分布式锁</p>
<p>缺点:锁的失效时间难控制、容易产生死锁、非阻塞式、不可重入</p>
<p><strong>3.**</strong>使用zookeeper实现分布式锁**</p>
<p><strong>实现相对简单、可靠性强、使用临时节点，失效时间容易控制</strong></p>
<h2 id="什么是分布式锁"><a href="#什么是分布式锁" class="headerlink" title="什么是分布式锁"></a>什么是分布式锁</h2><p>分布式锁一般用在分布式系统或者多个应用中，用来控制同一任务是否执行或者任务的执行顺序。在项目中，部署了多个tomcat应用，在执行定时任务时就会遇到同一任务可能执行多次的情况，我们可以借助分布式锁，保证在同一时间只有一个tomcat应用执行了定时任务</p>
<h2 id="使用Zookeeper实现分布式锁"><a href="#使用Zookeeper实现分布式锁" class="headerlink" title="使用Zookeeper实现分布式锁"></a>使用Zookeeper实现分布式锁</h2><h3 id="Zookeeper实现分布式锁原理"><a href="#Zookeeper实现分布式锁原理" class="headerlink" title="Zookeeper实现分布式锁原理"></a>Zookeeper实现分布式锁原理</h3><p>使用zookeeper创建临时序列节点来实现分布式锁，适用于顺序执行的程序，大体思路就是创建临时序列节点，找出最小的序列节点，获取分布式锁，程序执行完成之后此序列节点消失，通过watch来监控节点的变化，从剩下的节点的找到最小的序列节点，获取分布式锁，执行相应处理，依次类推……</p>
<p>实现步骤:</p>
<p>多个Jvm同时在Zookeeper上创建同一个相同的节点( /Lock)</p>
<p>zk节点唯一的！ 不能重复！节点类型为临时节点， jvm1创建成功时候，jvm2和jvm3创建节点时候会报错，该节点已经存在。这时候 jvm2和jvm3进行等待。</p>
<p> jvm1的程序现在执行完毕，执行释放锁。关闭当前会话。临时节点不复存在了并且事件通知Watcher，jvm2和jvm3继续创建。               </p>
<p> ps：zk强制关闭时候，通知会有延迟。但是close（）方法关闭时候，延迟小</p>
<p>  如果程序一直不处理完，可能导致思索（其他的一直等待）。设置有效期~ 直接close（）掉 其实连接也是有有效期设置的 大家可以找下相关资料看下哦</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/06/幂等性保证机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen ZeTao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/weixin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddd `Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/06/幂等性保证机制/" itemprop="url">幂等性保证机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-06T20:44:16+08:00">
                2019-10-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="幂等性概念"><a href="#幂等性概念" class="headerlink" title="幂等性概念"></a><strong>幂等性概念</strong></h2><p>在编程中.一个幂等操作的特点是其<strong>任意多次执行所产生的影响均与一次执行的影响相同。</strong>指可以使用相同参数重复执行，并能获得相同结果，<strong>不用担心重复执行会对系统造成改变</strong>。</p>
<h2 id="幂等性场景"><a href="#幂等性场景" class="headerlink" title="幂等性场景"></a><strong>幂等性场景</strong></h2><ul>
<li>查询操作：查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作；</li>
<li>删除操作：删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个) ；</li>
<li>修改操作：多次修改，因为主键约束，修改一次和修改多次，如果数据没变，操作相同。</li>
</ul>
<h2 id="保证幂等性措施"><a href="#保证幂等性措施" class="headerlink" title="保证幂等性措施"></a>保证幂等性措施</h2><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>防止<strong>新增</strong>脏数据。比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，所以一个用户新增成功一个资金账户记录。要点：唯一索引或唯一组合索引来防止新增数据存在脏数据（当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可）；需要合适的业务唯一字段</p>
<h3 id="token机制"><a href="#token机制" class="headerlink" title="token机制"></a>token机制</h3><p>防止页面重复提交。原理上通过session token来实现的(<strong>也可以通过redis来实现</strong>)。当客户端<strong>请求页面时，服务器会生成一个随机数Token，并且将Token放置到session当中</strong>，然后将Token发给客户端（一般通过<strong>构造hidden表单</strong>）。下次客户端提交请求时，Token会<strong>随着表单一起提交到服务器端</strong>。</p>
<p>服务器端<strong>第一次验证相同过后，会将session中的Token值更新下</strong>，<strong>若用户重复提交，第二次的验证判断将失败，因为用户提交的表单中的Token没变，但服务器端session中Token已经改变了。</strong></p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>获取数据的时候加锁获取。select * from table_xxx where id=’xxx’ for update;<br>注意：<strong>id字段一定是主键或者唯一索引，不然是锁表，会死人的</strong>；悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用；</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p><strong>只是在更新数据那一刻锁表</strong>，其他时间不锁表，所以相对于悲观锁，效率更高。乐观锁的实现方式多种多样可以通过version或者其他状态条件：</p>
<ol>
<li>通过版本号实现update table_xxx set name=#{name},version=version+1 where version=#{version}；</li>
<li>通过条件限制 update table_xxx set avai_amount=avai_amount-#subAmount# where<br>avai_amount-#subAmount# &gt;= 0要求：quality-#subQuality# &gt;= 0<br>，这个情景适合不用版本号，只更新是做数据安全校验，适合库存模型，扣份额和回滚份额，性能更高；</li>
</ol>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>如果是分布式系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。要点：某个长流程处理过程要求不能并发执行，可以<strong>在流程执行之前根据某个标志(用户ID+后缀等)获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(分布式锁要第三方系统提供)；</strong></p>
<h3 id="select-insert"><a href="#select-insert" class="headerlink" title="select + insert"></a>select + insert</h3><p>并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，<strong>先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了。</strong>注意：<strong>核心高并发流程不要用这种方法；</strong></p>
<h3 id="状态机幂等"><a href="#状态机幂等" class="headerlink" title="状态机幂等"></a>状态机幂等</h3><p>在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。注意：订单等单据类业务，存在很长的状态流转，一定要深刻理解状态机，对业务系统设计能力提高有很大帮助</p>
<h3 id="对外提供接口的api如何保证幂等"><a href="#对外提供接口的api如何保证幂等" class="headerlink" title="对外提供接口的api如何保证幂等"></a>对外提供接口的api如何保证幂等</h3><p>如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号；source+seq在数据库里面做唯一索引，防止多次付款(并发时，只能处理一个请求) 。<br>重点：对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/06/深入理解AQS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen ZeTao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/weixin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddd `Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/06/深入理解AQS/" itemprop="url">深入理解AQS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-06T20:39:45+08:00">
                2019-10-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h2><p>当共享资源被某个线程占有，其他请求该资源的线程将会阻塞，从而进入同步队列。就数据结构而言，队列的实现方式无外乎两者一是通过数组的形式，另外一种则是链表的形式。AQS中的同步队列则是<strong>通过链式方式</strong>进行实现。同步队列是<strong>带头结点的链式存储结构</strong>。</p>
<p>在AQS有一个静态内部类<strong>Node</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatile int waitStatus //节点状态 volatile Node prev //当前节点/线程的前驱节点 volatile Node next; //当前节点/线程的后继节点 volatile Thread thread;//加入同步队列的线程引用 Node nextWaiter;//等待队列中的下一个节点</span><br></pre></td></tr></table></figure>
<p><strong>节点的状态</strong>有以下这些</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int CANCELLED =  1//节点从同步队列中取消 int SIGNAL = -1//后继节点的线程处于等待状态，如果当前节点释放同步状态会通知后继节点，使得后继节点的线程能够运行； int CONDITION = -2//当前节点进入等待队列中 int PROPAGATE = -3//表示下一次共享式同步状态获取将会无条件传播下去 int INITIAL = 0;//初始状态`</span><br></pre></td></tr></table></figure>
<p>AQS中有两个重要的成员变量，通过头尾指针来管理同步队列，同时实现包括获取锁失败的线程进行入队，释放锁时对同步队列中的线程进行通知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private transient volatile Node head;private transient volatile Node tail;</span><br></pre></td></tr></table></figure>
<p><a href="https://a5223594.github.io/2019/10/06/深入理解AQS/163261637bb25796.png" target="_blank" rel="noopener"><img src="https://a5223594.github.io/2019/10/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AQS/163261637bb25796.png" alt="img"></a></p>
<p>调用lock()方法是获取独占式锁，获取失败就将当前线程加入同步队列，成功则线程执行。而lock()方法实际上会调用AQS的<strong>acquire()</strong>方法，源码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//先看同步状态是否获取成功，如果成功则方法结束返回 		//若失败则先调用addWaiter()方法再调用acquireQueued()方法        public final void acquire(int arg) &#123;     if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))         selfInterrupt();&#125;</span><br></pre></td></tr></table></figure>
<p>acquire根据当前获得同步状态成功与否做了两件事情：1. 成功，则方法结束返回，2. 失败，则先调用addWaiter()然后在调用acquireQueued()方法。</p>
<h3 id="addWaiter-源码"><a href="#addWaiter-源码" class="headerlink" title="addWaiter()源码"></a><strong>addWaiter()</strong>源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;		// 1. 将当前线程构建成Node类型        Node node = new Node(Thread.currentThread(), mode);        // Try the fast path of enq; backup to full enq on failure        // 2. 当前尾节点是否为null？		Node pred = tail;        if (pred != null) &#123;			// 2.2 将当前节点尾插入的方式插入同步队列中            node.prev = pred;            if (compareAndSetTail(pred, node)) &#123;                pred.next = node;                return node;            &#125;        &#125;		// 2.1. 当前同步队列尾节点为null，说明当前线程是第一个加入同步队列进行等待的线程        enq(node);        return node;&#125;</span><br></pre></td></tr></table></figure>
<p>程序的逻辑主要分为两个部分：<strong>1. 当前同步队列的尾节点为null，调用方法enq()插入;2. 当前队列的尾节点不为null，则采用尾插入（compareAndSetTail（）方法）的方式入队。</strong>另外还会有另外一个问题：如果 <code>if (compareAndSetTail(pred, node))</code>为false怎么办？会继续执行到enq()方法，同时很明显compareAndSetTail是一个CAS操作，通常来说如果CAS操作失败会继续自旋（死循环,在enq中自旋）进行重试。</p>
<h3 id="enq-源码"><a href="#enq-源码" class="headerlink" title="enq()源码"></a>enq()源码</h3><p><strong>1. 处理当前同步队列尾节点为null时进行入队操作；2. 如果CAS尾插入节点失败后负责自旋进行尝试。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;        for (;;) &#123;            Node t = tail;			if (t == null) &#123; // Must initialize				//1. 构造头结点                if (compareAndSetHead(new Node()))                    tail = head;            &#125; else &#123;				// 2. 尾插入，CAS操作失败自旋尝试                node.prev = t;                 if (compareAndSetTail(t, node)) &#123;                    t.next = node;                    return t;                &#125;            &#125;        &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>获取独占式锁失败的线程包装成Node然后插入同步队列的过程，线程）会做什么事情了来保证自己能够有机会获得独占式锁？</p>
<h3 id="acquireQueued-源码"><a href="#acquireQueued-源码" class="headerlink" title="acquireQueued()源码"></a><strong>acquireQueued()</strong>源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;        boolean failed = true;        try &#123;            boolean interrupted = false;            for (;;) &#123;				// 1. 获得当前节点的先驱节点                final Node p = node.predecessor();				// 2. 当前节点能否获取独占式锁									// 2.1 如果当前节点的先驱节点是头结点并且成功获取同步状态，即可以获得独占式锁				// 链表是带头节点的表示头节点的下一个结点为第一个结点                if (p == head &amp;&amp; tryAcquire(arg)) &#123;					//队列头指针用指向当前节点                    setHead(node);					//释放前驱节点                    p.next = null; // help GC                    failed = false;                    //没有被中断，返回false，让selfInterrupt();不执行,让线程不被中断                    return interrupted;                &#125;				// 2.2 获取锁失败，线程进入等待状态等待获取独占式锁                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                    parkAndCheckInterrupt())                    interrupted = true;            &#125;        &#125; finally &#123;            if (failed)                cancelAcquire(node);        &#125;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如果先驱节点是头结点的并且成功获得同步状态的时候（if (p == head &amp;&amp; tryAcquire(arg))），当前节点所指向的线程能够获取锁</strong>。反之，获取锁失败进入等待状态。</p>
<p>acquireQueued()在自旋过程中主要完成了两件事情：</p>
<ol>
<li><strong>如果当前节点的前驱节点是头节点，并且能够获得同步状态的话，当前线程能够获得锁该方法执行结束退出</strong>；</li>
<li><strong>获取锁失败的话，先将当前结点的前驱结点状态设置成SIGNAL，然后调用LookSupport.park方法使得当前线程阻塞</strong>。</li>
</ol>
<h3 id="shouldParkAfterFailedAcquire-源码"><a href="#shouldParkAfterFailedAcquire-源码" class="headerlink" title="shouldParkAfterFailedAcquire()源码"></a>shouldParkAfterFailedAcquire()源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;    int ws = pred.waitStatus;    if (ws == Node.SIGNAL)        // 有个规定，就是当前结点的前驱结点状态一定要是-1，才能将当前结点park，        // 相当于你告诉你前面的人排到你的时候叫我，我睡个觉        // 至于为什么前驱结点要是signal,等到release的时候有用        return true;    if (ws &gt; 0) &#123; 		//ws大于0只有一个取消状态 		//做个循环将取消结点去掉        do &#123;            node.prev = pred = pred.prev;        &#125; while (pred.waitStatus &gt; 0);        pred.next = node;    &#125; else &#123;        //CAS将前驱结点的ws设置成-1，自旋在aquareQueued里        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);    &#125;    return false;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="parkAndCheckInterrupt-源码"><a href="#parkAndCheckInterrupt-源码" class="headerlink" title="parkAndCheckInterrupt()源码"></a>parkAndCheckInterrupt()源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final boolean parkAndCheckInterrupt() &#123;        //使得该线程阻塞		LockSupport.park(this);        return Thread.interrupted();&#125;</span><br></pre></td></tr></table></figure>
<h2 id="独占锁的释放"><a href="#独占锁的释放" class="headerlink" title="独占锁的释放"></a>独占锁的释放</h2><h3 id="release-源码"><a href="#release-源码" class="headerlink" title="release()源码"></a>release()源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;        if (tryRelease(arg)) &#123;            Node h = head;            if (h != null &amp;&amp; h.waitStatus != 0)                unparkSuccessor(h);            return true;        &#125;        return false;&#125;</span><br></pre></td></tr></table></figure>
<p>如果同步状态释放成功（tryRelease返回true）则会执行if块中的代码，当head指向的头结点不为null，并且该节点的状态值不为0的话才会执行unparkSuccessor()方法。</p>
<h3 id="unparkSuccessor-源码"><a href="#unparkSuccessor-源码" class="headerlink" title="unparkSuccessor()源码"></a>unparkSuccessor()源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private void unparkSuccessor(Node node) &#123;    /*     * If status is negative (i.e., possibly needing signal) try     * to clear in anticipation of signalling.  It is OK if this     * fails or if status is changed by waiting thread.     */    // 如果头结点为负数，可能为-1，尝试将其ws设置为0，失败也没关系    int ws = node.waitStatus;    if (ws &lt; 0)        compareAndSetWaitStatus(node, ws, 0);    /*     * Thread to unpark is held in successor, which is normally     * just the next node.  But if cancelled or apparently null,     * traverse backwards from tail to find the actual     * non-cancelled successor.     */	//向后遍历找到头节点的后继节点，不能为取消结点    Node s = node.next;    if (s == null || s.waitStatus &gt; 0) &#123;        s = null;        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)            if (t.waitStatus &lt;= 0)                s = t;    &#125;    if (s != null)		//后继节点不为null时唤醒该线程        LockSupport.unpark(s.thread);&#125;</span><br></pre></td></tr></table></figure>
<p>首先获取头节点的后继节点，当后继节点的时候会调用LookSupport.unpark()方法，该方法会唤醒该节点的后继节点所包装的线程。因此，<strong>每一次锁释放后就会唤醒队列中该节点的后继节点所引用的线程，从而进一步可以佐证获得锁的过程是一个FIFO（先进先出）的过程。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>线程获取锁失败，线程被封装成Node进行入队操作，核心方法在于addWaiter()和enq()，同时enq()完成对同步队列的头结点初始化工作以及CAS操作失败的重试</strong>;</p>
<p><strong>线程获取锁是一个自旋的过程，当且仅当 当前节点的前驱节点是头结点并且成功获得同步状态时，节点出队即该节点引用的线程获得锁，否则，当不满足条件时就会调用LookSupport.park()方法使得线程阻塞</strong>；</p>
<p><strong>释放锁的时候会唤醒后继节点；</strong></p>
<p><strong>在获取同步状态时，AQS维护一个同步队列，获取同步状态失败的线程会加入到队列中进行自旋；移除队列（或停止自旋）的条件是前驱节点是头结点并且成功获得了同步状态。在释放同步状态时，同步器会调用unparkSuccessor()方法唤醒后继节点。</strong></p>
<h2 id="可中断式获取锁"><a href="#可中断式获取锁" class="headerlink" title="可中断式获取锁"></a>可中断式获取锁</h2><p>唯一的区别是当<strong>parkAndCheckInterrupt</strong>返回true时即线程阻塞时该线程被中断，代码抛出被中断异常。而上面只是<code>interrupted = true;</code></p>
<h2 id="超时等待式获取锁"><a href="#超时等待式获取锁" class="headerlink" title="超时等待式获取锁"></a>超时等待式获取锁</h2><p>和上面类似，每次自旋都会重新计算超时时间</p>
<h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><p>共享锁的原理和独占锁差不多，区别在于aquire（arg）大于0就能获取锁，每次都是arg–</p>
<p>释放大概是CAS释放多个线程，保证一定的顺序性</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/06/redis底层数据结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen ZeTao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/weixin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddd `Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/06/redis底层数据结构/" itemprop="url">redis底层数据结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-06T20:37:54+08:00">
                2019-10-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  20
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="通俗易懂的Redis数据结构基础教程"><a href="#通俗易懂的Redis数据结构基础教程" class="headerlink" title="通俗易懂的Redis数据结构基础教程"></a>通俗易懂的Redis数据结构基础教程</h1><p><img src="https://user-gold-cdn.xitu.io/2018/7/23/164c6b32b5f679dc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>Redis有5个基本数据结构，string、list、hash、set和zset。它们是日常开发中使用频率非常高应用最为广泛的数据结构，把这5个数据结构都吃透了，你就掌握了Redis应用知识的一半了。</p>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p><img src="https://user-gold-cdn.xitu.io/2018/7/22/164c182f83ceb3b5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>首先我们从string谈起。string表示的是一个可变的字节数组，我们初始化字符串的内容、可以拿到字符串的长度，可以获取string的子串，可以覆盖string的子串内容，可以追加子串。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/24/164caaff402d2617?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>Redis的字符串是动态字符串，是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配，如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p>
<p><strong>初始化字符串</strong> 需要提供「变量名称」和「变量的内容」</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; set ireader beijing.zhangyue.keji.gufen.youxian.gongsi</span><br><span class="line">OK</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>获取字符串的内容</strong> 提供「变量名称」</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; get ireader</span><br><span class="line">&quot;beijing.zhangyue.keji.gufen.youxian.gongsi&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>获取字符串的长度</strong> 提供「变量名称」</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; strlen ireader</span><br><span class="line">(integer) 42</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>获取子串</strong> 提供「变量名称」以及开始和结束位置[start, end]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; getrange ireader 28 34</span><br><span class="line">&quot;youxian&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>覆盖子串</strong> 提供「变量名称」以及开始位置和目标子串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; setrange ireader 28 wooxian</span><br><span class="line">(integer) 42  # 返回长度</span><br><span class="line">&gt; get ireader</span><br><span class="line">&quot;beijing.zhangyue.keji.gufen.wooxian.gongsi&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>追加子串</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; append ireader .hao</span><br><span class="line">(integer) 46 # 返回长度</span><br><span class="line">&gt; get ireader</span><br><span class="line">&quot;beijing.zhangyue.keji.gufen.wooxian.gongsi.hao&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>遗憾的是字符串没有提供字串插入方法和子串删除方法。</p>
<p><strong>计数器</strong> 如果字符串的内容是一个整数，那么还可以将字符串当成计数器来使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; set ireader 42</span><br><span class="line">OK</span><br><span class="line">&gt; get ireader</span><br><span class="line">&quot;42&quot;</span><br><span class="line">&gt; incrby ireader 100</span><br><span class="line">(integer) 142</span><br><span class="line">&gt; get ireader</span><br><span class="line">&quot;142&quot;</span><br><span class="line">&gt; decrby ireader 100</span><br><span class="line">(integer) 42</span><br><span class="line">&gt; get ireader</span><br><span class="line">&quot;42&quot;</span><br><span class="line">&gt; incr ireader  # 等价于incrby ireader 1</span><br><span class="line">(integer) 43</span><br><span class="line">&gt; decr ireader  # 等价于decrby ireader 1</span><br><span class="line">(integer) 42</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>计数器是有范围的，它不能超过Long.Max，不能低于Long.MIN</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; set ireader 9223372036854775807</span><br><span class="line">OK</span><br><span class="line">&gt; incr ireader</span><br><span class="line">(error) ERR increment or decrement would overflow</span><br><span class="line">&gt; set ireader -9223372036854775808</span><br><span class="line">OK</span><br><span class="line">&gt; decr ireader</span><br><span class="line">(error) ERR increment or decrement would overflow</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>过期和删除</strong> 字符串可以使用del指令进行主动删除，可以使用expire指令设置过期时间，到点会自动删除，这属于被动删除。可以使用ttl指令获取字符串的寿命。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; expire ireader 60</span><br><span class="line">(integer) 1  # 1表示设置成功，0表示变量ireader不存在</span><br><span class="line">&gt; ttl ireader</span><br><span class="line">(integer) 50  # 还有50秒的寿命，返回-2表示变量不存在，-1表示没有设置过期时间</span><br><span class="line">&gt; del ireader</span><br><span class="line">(integer) 1  # 删除成功返回1</span><br><span class="line">&gt; get ireader</span><br><span class="line">(nil)  # 变量ireader没有了</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p><img src="https://user-gold-cdn.xitu.io/2018/7/22/164c25d671d13466?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>Redis将列表数据结构命名为list而不是array，是因为列表的存储结构用的是链表而不是数组，而且链表还是双向链表。因为它是链表，所以随机定位性能较弱，首尾插入删除性能较优。如果list的列表长度很长，使用时我们一定要关注链表相关操作的时间复杂度。</p>
<p><strong>负下标</strong> 链表元素的位置使用自然数<code>0,1,2,....n-1</code>表示，还可以使用负数<code>-1,-2,...-n</code>来表示，<code>-1</code>表示「倒数第一」，<code>-2</code>表示「倒数第二」，那么<code>-n</code>就表示第一个元素，对应的下标为<code>0</code>。</p>
<p><strong>队列／堆栈</strong> 链表可以从表头和表尾追加和移除元素，结合使用rpush/rpop/lpush/lpop四条指令，可以将链表作为队列或堆栈使用，左向右向进行都可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 右进左出</span><br><span class="line">&gt; rpush ireader go</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; rpush ireader java python</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; lpop ireader</span><br><span class="line">&quot;go&quot;</span><br><span class="line">&gt; lpop ireader</span><br><span class="line">&quot;java&quot;</span><br><span class="line">&gt; lpop ireader</span><br><span class="line">&quot;python&quot;</span><br><span class="line"># 左进右出</span><br><span class="line">&gt; lpush ireader go java python</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; rpop ireader</span><br><span class="line">&quot;go&quot;</span><br><span class="line">...</span><br><span class="line"># 右进右出</span><br><span class="line">&gt; rpush ireader go java python</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; rpop ireader </span><br><span class="line">&quot;python&quot;</span><br><span class="line">...</span><br><span class="line"># 左进左出</span><br><span class="line">&gt; lpush ireader go java python</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; lpop ireader</span><br><span class="line">&quot;python&quot;</span><br><span class="line">...</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>在日常应用中，列表常用来作为异步队列来使用。</p>
<p><strong>长度</strong> 使用llen指令获取链表长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush ireader go java python</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; llen ireader</span><br><span class="line">(integer) 3</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>随机读</strong> 可以使用lindex指令访问指定位置的元素，使用lrange指令来获取链表子元素列表，提供start和end下标参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush ireader go java python</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; lindex ireader 1</span><br><span class="line">&quot;java&quot;</span><br><span class="line">&gt; lrange ireader 0 2</span><br><span class="line">1) &quot;go&quot;</span><br><span class="line">2) &quot;java&quot;</span><br><span class="line">3) &quot;python&quot;</span><br><span class="line">&gt; lrange ireader 0 -1  # -1表示倒数第一</span><br><span class="line">1) &quot;go&quot;</span><br><span class="line">2) &quot;java&quot;</span><br><span class="line">3) &quot;python&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>使用lrange获取全部元素时，需要提供end_index，如果没有负下标，就需要首先通过llen指令获取长度，才可以得出end_index的值，有了负下标，使用-1代替end_index就可以达到相同的效果。</p>
<p><strong>修改元素</strong> 使用lset指令在指定位置修改元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush ireader go java python</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; lset ireader 1 javascript</span><br><span class="line">OK</span><br><span class="line">&gt; lrange ireader 0 -1</span><br><span class="line">1) &quot;go&quot;</span><br><span class="line">2) &quot;javascript&quot;</span><br><span class="line">3) &quot;python&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>插入元素</strong> 使用linsert指令在列表的中间位置插入元素，有经验的程序员都知道在插入元素时，我们经常搞不清楚是在指定位置的前面插入还是后面插入，所以antirez在linsert指令里增加了方向参数before/after来显示指示前置和后置插入。不过让人意想不到的是linsert指令并不是通过指定位置来插入，而是通过指定具体的值。这是因为在分布式环境下，列表的元素总是频繁变动的，意味着上一时刻计算的元素下标在下一时刻可能就不是你所期望的下标了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush ireader go java python</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; linsert ireader before java ruby</span><br><span class="line">(integer) 4</span><br><span class="line">&gt; lrange ireader 0 -1</span><br><span class="line">1) &quot;go&quot;</span><br><span class="line">2) &quot;ruby&quot;</span><br><span class="line">3) &quot;java&quot;</span><br><span class="line">4) &quot;python&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>到目前位置，我还没有在实际应用中发现插入指定的应用场景。</p>
<p><strong>删除元素</strong> 列表的删除操作也不是通过指定下标来确定元素的，你需要指定删除的最大个数以及元素的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush ireader go java python</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; lrem ireader 1 java</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; lrange ireader 0 -1</span><br><span class="line">1) &quot;go&quot;</span><br><span class="line">2) &quot;python&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>定长列表</strong> 在实际应用场景中，我们有时候会遇到「定长列表」的需求。比如要以走马灯的形式实时显示中奖用户名列表，因为中奖用户实在太多，能显示的数量一般不超过100条，那么这里就会使用到定长列表。维持定长列表的指令是ltrim，需要提供两个参数start和end，表示需要保留列表的下标范围，范围之外的所有元素都将被移除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush ireader go java python javascript ruby erlang rust cpp</span><br><span class="line">(integer) 8</span><br><span class="line">&gt; ltrim ireader -3 -1</span><br><span class="line">OK</span><br><span class="line">&gt; lrange ireader 0 -1</span><br><span class="line">1) &quot;erlang&quot;</span><br><span class="line">2) &quot;rust&quot;</span><br><span class="line">3) &quot;cpp&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>如果指定参数的end对应的真实下标小于start，其效果等价于del指令，因为这样的参数表示需要需要保留列表元素的下标范围为空。</p>
<p><strong>快速列表</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/27/164d91746fbe0442?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>如果再深入一点，你会发现Redis底层存储的还不是一个简单的linkedlist，而是称之为快速链表quicklist的一个结构。首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。所以Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p><img src="https://user-gold-cdn.xitu.io/2018/7/23/164c4eaf9edf608d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>哈希等价于Java语言的HashMap或者是Python语言的dict，在实现结构上它使用二维结构，第一维是数组，第二维是链表，hash的内容key和value存放在链表中，数组里存放的是链表的头指针。通过key查找元素时，先计算key的hashcode，然后用hashcode对数组的长度进行取模定位到链表的表头，再对链表进行遍历获取到相应的value值，链表的作用就是用来将产生了「hash碰撞」的元素串起来。Java语言开发者会感到非常熟悉，因为这样的结构和HashMap是没有区别的。哈希的第一维数组的长度也是2^n。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/23/164c4dcd14c00534?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><strong>增加元素</strong> 可以使用hset一次增加一个键值对，也可以使用hmset一次增加多个键值对</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; hset ireader go fast</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hmset ireader java fast python slow</span><br><span class="line">OK</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>获取元素</strong> 可以通过hget定位具体key对应的value，可以通过hmget获取多个key对应的value，可以使用hgetall获取所有的键值对，可以使用hkeys和hvals分别获取所有的key列表和value列表。这些操作和Java语言的Map接口是类似的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; hmset ireader go fast java fast python slow</span><br><span class="line">OK</span><br><span class="line">&gt; hget ireader go</span><br><span class="line">&quot;fast&quot;</span><br><span class="line">&gt; hmget ireader go python</span><br><span class="line">1) &quot;fast&quot;</span><br><span class="line">2) &quot;slow&quot;</span><br><span class="line">&gt; hgetall ireader</span><br><span class="line">1) &quot;go&quot;</span><br><span class="line">2) &quot;fast&quot;</span><br><span class="line">3) &quot;java&quot;</span><br><span class="line">4) &quot;fast&quot;</span><br><span class="line">5) &quot;python&quot;</span><br><span class="line">6) &quot;slow&quot;</span><br><span class="line">&gt; hkeys ireader</span><br><span class="line">1) &quot;go&quot;</span><br><span class="line">2) &quot;java&quot;</span><br><span class="line">3) &quot;python&quot;</span><br><span class="line">&gt; hvals ireader</span><br><span class="line">1) &quot;fast&quot;</span><br><span class="line">2) &quot;fast&quot;</span><br><span class="line">3) &quot;slow&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>删除元素</strong> 可以使用hdel删除指定key，hdel支持同时删除多个key</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; hmset ireader go fast java fast python slow</span><br><span class="line">OK</span><br><span class="line">&gt; hdel ireader go</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hdel ireader java python</span><br><span class="line">(integer) 2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>判断元素是否存在</strong> 通常我们使用hget获得key对应的value是否为空就直到对应的元素是否存在了，不过如果value的字符串长度特别大，通过这种方式来判断元素存在与否就略显浪费，这时可以使用hexists指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; hmset ireader go fast java fast python slow</span><br><span class="line">OK</span><br><span class="line">&gt; hexists ireader go</span><br><span class="line">(integer) 1</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>计数器</strong> hash结构还可以当成计数器来使用，对于内部的每一个key都可以作为独立的计数器。如果value值不是整数，调用hincrby指令会出错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; hincrby ireader go 1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hincrby ireader python 4</span><br><span class="line">(integer) 4</span><br><span class="line">&gt; hincrby ireader java 4</span><br><span class="line">(integer) 4</span><br><span class="line">&gt; hgetall ireader</span><br><span class="line">1) &quot;go&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;python&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;java&quot;</span><br><span class="line">6) &quot;4&quot;</span><br><span class="line">&gt; hset ireader rust good</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hincrby ireader rust 1</span><br><span class="line">(error) ERR hash value is not an integer</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>扩容</strong> 当hash内部的元素比较拥挤时(hash碰撞比较频繁)，就需要进行扩容。扩容需要申请新的两倍大小的数组，然后将所有的键值对重新分配到新的数组下标对应的链表中(rehash)。如果hash结构很大，比如有上百万个键值对，那么一次完整rehash的过程就会耗时很长。这对于单线程的Redis里来说有点压力山大。所以Redis采用了渐进式rehash的方案。它会同时保留两个新旧hash结构，在后续的定时任务以及hash结构的读写指令中将旧结构的元素逐渐迁移到新的结构中。这样就可以避免因扩容导致的线程卡顿现象。</p>
<p><strong>缩容</strong> Redis的hash结构不但有扩容还有缩容，从这一点出发，它要比Java的HashMap要厉害一些，Java的HashMap只有扩容。缩容的原理和扩容是一致的，只不过新的数组大小要比旧数组小一倍。</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>Java程序员都知道HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p>
<p><strong>增加元素</strong> 可以一次增加多个元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; sadd ireader go java python</span><br><span class="line">(integer) 3</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>读取元素</strong> 使用smembers列出所有元素，使用scard获取集合长度，使用srandmember获取随机count个元素，如果不提供count参数，默认为1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; sadd ireader go java python</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; smembers ireader</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;python&quot;</span><br><span class="line">3) &quot;go&quot;</span><br><span class="line">&gt; scard ireader</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; srandmember ireader</span><br><span class="line">&quot;java&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>删除元素</strong> 使用srem删除一到多个元素，使用spop删除随机一个元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; sadd ireader go java python rust erlang</span><br><span class="line">(integer) 5</span><br><span class="line">&gt; srem ireader go java</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; spop ireader</span><br><span class="line">&quot;erlang&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>判断元素是否存在</strong> 使用sismember指令，只能接收单个元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; sadd ireader go java python rust erlang</span><br><span class="line">(integer) 5</span><br><span class="line">&gt; sismember ireader rust</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sismember ireader javascript</span><br><span class="line">(integer) 0</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h2 id="sortedset"><a href="#sortedset" class="headerlink" title="sortedset"></a>sortedset</h2><p><img src="https://user-gold-cdn.xitu.io/2018/7/23/164c4ec77aac6132?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构<code>Map&lt;String, Double&gt;</code>，可以给每一个元素value赋予一个权重<code>score</code>，另一方面它又类似于<code>TreeSet</code>，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p>
<p>zset底层实现使用了两个数据结构，第一个是hash，第二个是跳跃列表，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。跳跃列表的目的在于给元素value排序，根据score的范围获取元素列表。</p>
<p><strong>增加元素</strong> 通过zadd指令可以增加一到多个value/score对，score放在前面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; zadd ireader 4.0 python</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd ireader 4.0 java 1.0 go</span><br><span class="line">(integer) 2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>长度</strong> 通过指令zcard可以得到zset的元素个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; zcard ireader</span><br><span class="line">(integer) 3</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>删除元素</strong> 通过指令zrem可以删除zset中的元素，可以一次删除多个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; zrem ireader go python</span><br><span class="line">(integer) 2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>计数器</strong> 同hash结构一样，zset也可以作为计数器使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; zadd ireader 4.0 python 4.0 java 1.0 go</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; zincrby ireader 1.0 python</span><br><span class="line">&quot;5&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>获取排名和分数</strong> 通过zscore指令获取指定元素的权重，通过zrank指令获取指定元素的正向排名，通过zrevrank指令获取指定元素的反向排名[倒数第一名]。正向是由小到大，负向是由大到小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; zscore ireader python</span><br><span class="line">&quot;5&quot;</span><br><span class="line">&gt; zrank ireader go  # 分数低的排名考前，rank值小</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; zrank ireader java</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrank ireader python</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; zrevrank ireader python</span><br><span class="line">(integer) 0</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>根据排名范围获取元素列表</strong> 通过zrange指令指定排名范围参数获取对应的元素列表，携带withscores参数可以一并获取元素的权重。通过zrevrange指令按负向排名获取元素列表[倒数]。正向是由小到大，负向是由大到小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; zrange ireader 0 -1  # 获取所有元素</span><br><span class="line">1) &quot;go&quot;</span><br><span class="line">2) &quot;java&quot;</span><br><span class="line">3) &quot;python&quot;</span><br><span class="line">&gt; zrange ireader 0 -1 withscores</span><br><span class="line">1) &quot;go&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;java&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;python&quot;</span><br><span class="line">6) &quot;5&quot;</span><br><span class="line">&gt; zrevrange ireader 0 -1 withscores</span><br><span class="line">1) &quot;python&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;java&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;go&quot;</span><br><span class="line">6) &quot;1&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>根据score范围获取列表</strong> 通过zrangebyscore指令指定score范围获取对应的元素列表。通过zrevrangebyscore指令获取倒排元素列表。正向是由小到大，负向是由大到小。参数<code>-inf</code>表示负无穷，<code>+inf</code>表示正无穷。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; zrangebyscore ireader 0 5</span><br><span class="line">1) &quot;go&quot;</span><br><span class="line">2) &quot;java&quot;</span><br><span class="line">3) &quot;python&quot;</span><br><span class="line">&gt; zrangebyscore ireader -inf +inf withscores</span><br><span class="line">1) &quot;go&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;java&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;python&quot;</span><br><span class="line">6) &quot;5&quot;</span><br><span class="line">&gt; zrevrangebyscore ireader +inf -inf withscores  # 注意正负反过来了</span><br><span class="line">1) &quot;python&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;java&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">5) &quot;go&quot;</span><br><span class="line">6) &quot;1&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>根据范围移除元素列表</strong> 可以通过排名范围，也可以通过score范围来一次性移除多个元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; zremrangebyrank ireader 0 1</span><br><span class="line">(integer) 2  # 删掉了2个元素</span><br><span class="line">&gt; zadd ireader 4.0 java 1.0 go</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; zremrangebyscore ireader -inf 4</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; zrange ireader 0 -1</span><br><span class="line">1) &quot;python&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>跳跃列表</strong> zset内部的排序功能是通过「跳跃列表」数据结构来实现的，它的结构非常特殊，也比较复杂。这一块的内容深度读者要有心理准备。</p>
<p>因为zset要支持随机的插入和删除，所以它不好使用数组来表示。我们先看一个普通的链表结构。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/23/164c5a90442cd51a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>我们需要这个链表按照score值进行排序。这意味着当有新元素需要插入时，需要定位到特定位置的插入点，这样才可以继续保证链表是有序的。通常我们会通过二分查找来找到插入点，但是二分查找的对象必须是数组，只有数组才可以支持快速位置定位，链表做不到，那该怎么办？</p>
<p>想想一个创业公司，刚开始只有几个人，团队成员之间人人平等，都是联合创始人。随着公司的成长，人数渐渐变多，团队沟通成本随之增加。这时候就会引入组长制，对团队进行划分。每个团队会有一个组长。开会的时候分团队进行，多个组长之间还会有自己的会议安排。公司规模进一步扩展，需要再增加一个层级——部门，每个部门会从组长列表中推选出一个代表来作为部长。部长们之间还会有自己的高层会议安排。</p>
<p>跳跃列表就是类似于这种层级制，最下面一层所有的元素都会串起来。然后每隔几个元素挑选出一个代表来，再将这几个代表使用另外一级指针串起来。然后在这些代表里再挑出二级代表，再串起来。最终就形成了金字塔结构。</p>
<p>想想你老家在世界地图中的位置：亚洲–&gt;中国-&gt;安徽省-&gt;安庆市-&gt;枞阳县-&gt;汤沟镇-&gt;田间村-&gt;xxxx号，也是这样一个类似的结构。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/23/164c5bb13c6da230?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>「跳跃列表」之所以「跳跃」，是因为内部的元素可能「身兼数职」，比如上图中间的这个元素，同时处于L0、L1和L2层，可以快速在不同层次之间进行「跳跃」。</p>
<p>定位插入点时，先在顶层进行定位，然后下潜到下一级定位，一直下潜到最底层找到合适的位置，将新元素插进去。你也许会问那新插入的元素如何才有机会「身兼数职」呢？</p>
<p>跳跃列表采取一个随机策略来决定新元素可以兼职到第几层，首先L0层肯定是100%了，L1层只有50%的概率，L2层只有25%的概率，L3层只有12.5%的概率，一直随机到最顶层L31层。绝大多数元素都过不了几层，只有极少数元素可以深入到顶层。列表中的元素越多，能够深入的层次就越深，能进入到顶层的概率就会越大。</p>
<p>这还挺公平的，能不能进入中央不是靠拼爹，而是看运气。</p>
<p>转载 掘金 老钱 原文链接：<a href="https://juejin.im/post/5b53ee7e5188251aaa2d2e16#heading-0" target="_blank" rel="noopener">https://juejin.im/post/5b53ee7e5188251aaa2d2e16#heading-0</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/06/CountDownLatch底层实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen ZeTao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/weixin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddd `Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/06/CountDownLatch底层实现/" itemprop="url">CountDownLatch底层实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-06T11:45:07+08:00">
                2019-10-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、CountDownLatch 概述<br>1.1 什么是 CountDLatch</p>
<p>闭锁（CountDownLatch）是 java.util.concurrent 包下的一种同步工具类。闭锁可以用来确保某些活动直到其他活动都完成后才执行。</p>
<p>闭锁相当于一扇门：在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有任何线程能通过，当达到结束状态时，这扇门会打开，并允许所有的线程通过。</p>
<p>1.2 CountDownLatch 的应用场景</p>
<p>确保某个计算在其需要的所有资源都被初始化之后才执行<br>确保某个服务在其依赖的所有其他服务都已经启动之后才启动<br>等待直到每个操作的所有参与者都就绪再执行（比如打麻将时需要等待四个玩家就绪）<br>1.3 CountDownLatch 简单应用</p>
<p>我们知道 4 个人玩纸牌游戏一定会先等所有玩家就绪后才会发牌，下面我们就来用闭锁简单的模拟一下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化需要等待的 4 个事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 4 个线程分别代表 4 个玩家</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123; System.out.println(<span class="string">"玩家 1 已就绪"</span>); latch.countDown(); &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123; System.out.println(<span class="string">"玩家 2 已就绪"</span>); latch.countDown(); &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123; System.out.println(<span class="string">"玩家 3 已就绪"</span>); latch.countDown(); &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123; System.out.println(<span class="string">"玩家 4 已就绪"</span>); latch.countDown(); &#125;).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 所有玩家就绪前一直阻塞</span></span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">"所有玩家已就绪，请发牌"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是控制台输出：<br><img src="https://img-blog.csdnimg.cn/2019031118084154.jpg" alt></p>
<p>二、CountDownLatch 原理分析<br>CountDownLatch 底层是基于 AQS 实现的，如果不懂 AQS 原理的小伙伴需要先了解下 AQS 再来看这篇文章。</p>
<p>2.1 API 相关方法</p>
<p>构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="comment">// 初始化 count 值</span></span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CountDownLatch 内部有一个 Sync 同步对象，这个对象是一个内部类实现了 AQS，下面我们会具体来看方法实现。</p>
<p>await 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 共享式检查是否中断，如果中断抛出异常</span></span><br><span class="line">    <span class="comment">// 调用 tryAcquireShared 方法尝试获取同步状态，当闭锁内的线程执行完毕后尝试获取成功，直接返回</span></span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>countDown 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 调用 releaseShared 每次使同步状态值减 1</span></span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的 API 我们应该能知道其大概的原理了，在 CountDownLatch 初始化的时候会有一个初始的同步状态值，这个同步状态值可以理解为放行前的所要执行的线程数，每次调用 countDown 方法时就把同步状态值减 1，await 方法会自旋检查同步状态值是否为 0，当不为 0 时会阻塞线程，当为 0 时会直接返回，该方法是支持相应 中断的，当线程中断时会抛出异常。因此该方法可以理解为一扇门，只有当指定数量的线程执行完后，才会执行后续的代码。</p>
<p>上面我们已经理解了大概的流程，下面来看下具体的实现代码。</p>
<p>2.2 Sync 同步类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化闭锁 count 值</span></span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  通过共享方式尝试获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 通过共享方式尝试释放锁</span></span><br><span class="line">	<span class="comment">// 因为该方法是线程共享的，因此需要通过 CAS 操作保证线程安全</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="comment">// 同步状态值在上一次置 0 时已经放行，因此返回 false</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 同步状态值 - 1</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 为 0 时返回 true</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>————————————————<br>版权声明：本文为CSDN博主「留兰香丶」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/codejas/article/details/88407572" target="_blank" rel="noopener">https://blog.csdn.net/codejas/article/details/88407572</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/weixin.jpg" alt="Chen ZeTao">
            
              <p class="site-author-name" itemprop="name">Chen ZeTao</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen ZeTao</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>



<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共104.1k字</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

  
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>
