<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="ddd `Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="ddd `Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ddd `Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>ddd `Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ddd `Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">czt的博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/29/扩展/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen ZeTao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/weixin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddd `Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/29/扩展/" itemprop="url">扩展</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-29T20:07:54+08:00">
                2019-09-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  11
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="9-28"><a href="#9-28" class="headerlink" title="9.28"></a>9.28</h1><p>在订单详情部分实现多缓存处理</p>
<p>redis 分布式缓存 +  tomcat 堆缓存 二级缓存架构</p>
<h4 id="redis搭建方案"><a href="#redis搭建方案" class="headerlink" title="redis搭建方案"></a>redis搭建方案</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis持久化+备份方案+容灾方案+replication（主从+读写分离）+sentinal（哨兵集群，3个节点，高可用性）</span><br><span class="line"></span><br><span class="line">可以支撑的数据量在10G以内，可以支撑的写QPS在几万左右，可以支撑的读QPS可以上10万以上（随你的需求，水平扩容slave节点就可以），可用性在99.99%</span><br><span class="line">可以用公司里的一些已有的数据，导入进去，几百万，一千万，进去</span><br><span class="line"></span><br><span class="line">做各种压力测试，性能，redis-benchmark，并发，QPS，高可用的演练，每台机器最大能存储多少数据量，横向扩容支撑更多数据</span><br><span class="line"></span><br><span class="line">基于测试环境还有测试数据，做各种演练，去摸索一些最适合自己的一些细节的东西</span><br></pre></td></tr></table></figure>
<p>如果页面的数据有变更，及时监听到，并且写入缓存中，提供高并发，高性能的访问</p>
<p>前端请求，请求服务器，先从redis中拿，redis中没有，本地搭建ehcache没有，再调用商品服务，从数据库中拿</p>
<p>企业级的大型缓存架构</p>
<h3 id="保证数据库与缓存的双写一致性"><a href="#保证数据库与缓存的双写一致性" class="headerlink" title="保证数据库与缓存的双写一致性"></a>保证数据库与缓存的双写一致性</h3><h3 id="分布式缓存重建问题，使用分布式锁实现"><a href="#分布式缓存重建问题，使用分布式锁实现" class="headerlink" title="分布式缓存重建问题，使用分布式锁实现"></a>分布式缓存重建问题，使用分布式锁实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">详细在文章关于zookeeper搭建分布式锁中</span><br></pre></td></tr></table></figure>
<h4 id="服务本地堆缓存，避免数据库直接裸奔"><a href="#服务本地堆缓存，避免数据库直接裸奔" class="headerlink" title="服务本地堆缓存，避免数据库直接裸奔"></a>服务本地堆缓存，避免数据库直接裸奔</h4><p>因为之前跟大家提过，三级缓存，多级缓存，服务本地堆缓存 + redis分布式缓存 + nginx本地缓存组成的</p>
<p>每一层缓存在高并发的场景下，都有其特殊的用途，需要综合利用多级的缓存，才能支撑住高并发场景下各种各样的特殊情况</p>
<p>服务本地堆缓存，作用，预防redis层的彻底崩溃，作为缓存的最后一道防线，避免数据库直接裸奔</p>
<p>服务本地堆缓存，我们用什么来做缓存，难道我们自己手写一个类或者程序去管理内存吗？？？java最流行的缓存的框架，ehcache</p>
<p>所以我们也是用ehcache来做本地的堆缓存</p>
<p>spring boot + ehcache整合起来，演示一下是怎么使用的</p>
<p>spring boot整合ehcache</p>
<p>（1）依赖</p>
<dependency><br>  <groupid>org.springframework.boot</groupid><br>  <artifactid>spring-boot-starter-data-jpa</artifactid><br></dependency><br><dependency><br>  <groupid>org.springframework</groupid><br>  <artifactid>spring-context-support</artifactid><br></dependency><br><dependency><br>  <groupid>net.sf.ehcache</groupid><br>  <artifactid>ehcache</artifactid><br>  <version>2.8.3</version><br></dependency>

<p>（2）缓存配置管理类</p>
<p>@Configuration<br>@EnableCaching<br>public class CacheConfiguration {</p>
<pre><code>@Bean
public EhCacheManagerFactoryBean ehCacheManagerFactoryBean(){
  EhCacheManagerFactoryBean cacheManagerFactoryBean = new EhCacheManagerFactoryBean();
  cacheManagerFactoryBean.setConfigLocation(new ClassPathResource(&quot;ehcache.xml&quot;));
  cacheManagerFactoryBean.setShared(true);
  return cacheManagerFactoryBean;
}

@Bean
public EhCacheCacheManager ehCacheCacheManager(EhCacheManagerFactoryBean bean){
  return new EhCacheCacheManager(bean.getObject());
}
</code></pre><p>}</p>
<p>（3）ehcache.xml</p>
<p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</p>
<ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:nonamespaceschemalocation="http://ehcache.org/ehcache.xsd" updatecheck="false"><br><br>    <diskstore path="java.io.tmpdir/Tmp_EhCache"><br><br>    <defaultcache eternal="false" maxelementsinmemory="1000" overflowtodisk="false" diskpersistent="false" timetoidleseconds="0" timetoliveseconds="0" memorystoreevictionpolicy="LRU"><br><br>    <cache name="local" eternal="false" maxelementsinmemory="1000" overflowtodisk="false" diskpersistent="false" timetoidleseconds="0" timetoliveseconds="0" memorystoreevictionpolicy="LRU"><br><br></cache></defaultcache></diskstore></ehcache>

<p>（4）CacheService</p>
<p>@Service(“cacheService”)<br>public class CacheServiceImpl implements CacheService {</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CACHE_NAME = <span class="string">"local"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Cacheable</span>(value = CACHE_NAME, key = <span class="string">"'key_'+#id"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ProductInfo <span class="title">findById</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="meta">@CachePut</span>(value = CACHE_NAME, key = <span class="string">"'key_'+#productInfo.getId()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ProductInfo <span class="title">saveProductInfo</span><span class="params">(ProductInfo productInfo)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> productInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>}</p>
<p>（5）写一个Controller测试一下ehcache的整合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheTestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> CacheService cacheService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span>(<span class="string">"/testPutCache"</span>)</span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPutCache</span><span class="params">(ProductInfo productInfo)</span> </span>&#123;</span><br><span class="line">    System.out.println(productInfo.getId() + <span class="string">":"</span> + productInfo.getName());  </span><br><span class="line">    cacheService.saveProductInfo(productInfo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span>(<span class="string">"/testGetCache"</span>)</span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ProductInfo <span class="title">testGetCache</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    ProductInfo productInfo = cacheService.findById(id);</span><br><span class="line">    System.out.println(productInfo.getId() + <span class="string">":"</span> + productInfo.getName()); </span><br><span class="line">    <span class="keyword">return</span> productInfo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ehcache已经整合进了我们的系统，spring boot</p>
<p>封装好了对ehcache本地缓存进行添加和获取的方法和service</p>
<p>小程序写入操作，防止并发中，HashMap的使用，改成使用ConcurrentHashMap</p>
<h1 id="10-1"><a href="#10-1" class="headerlink" title="10.1"></a>10.1</h1><h3 id="商品详情页的多级缓存架构"><a href="#商品详情页的多级缓存架构" class="headerlink" title="商品详情页的多级缓存架构"></a>商品详情页的多级缓存架构</h3><p>我们之前的三十讲，主要是在讲解redis如何支撑海量数据、高并发读写、高可用服务的架构，redis架构</p>
<p>redis架构，在我们的真正类似商品详情页读高并发的系统中，redis就是底层的缓存存储的支持</p>
<p>从这一讲开始，我们正式开始做业务系统的开发</p>
<p>亿级流量以上的电商网站的商品详情页的系统，商品详情页系统，大量的业务，十几个人做一两年，堆出来复杂的业务系统</p>
<p>几十个小时的课程，讲解复杂的业务</p>
<p>把整体的架构给大家讲解清楚，然后浓缩和精炼里面的业务，提取部分业务，做一些简化，把整个详情页系统的流程跑出来</p>
<p>架构，骨架，有少量的业务，血和肉，把整个项目串起来，在业务背景下，去学习架构</p>
<p>讲解商品详情页系统，缓存架构，90%大量的业务代码（没有什么技术含量），10%的最优技术含量的就是架构，上亿流量，每秒QPS几万，上十万的，读并发</p>
<p>读并发，缓存架构</p>
<p>1、上亿流量的商品详情页系统的多级缓存架构</p>
<p>很多人以为，做个缓存，其实就是用一下redis，访问一下，就可以了，简单的缓存</p>
<p>做复杂的缓存，支撑电商复杂的场景下的高并发的缓存，遇到的问题，非常非常之多，绝对不是说简单的访问一下redsi就可以了</p>
<p>采用三级缓存：nginx本地缓存+redis分布式缓存+tomcat堆缓存的多级缓存架构</p>
<p>时效性要求非常高的数据：库存</p>
<p>一般来说，显示的库存，都是时效性要求会相对高一些，因为随着商品的不断的交易，库存会不断的变化</p>
<p>当然，我们就希望当库存变化的时候，尽可能更快将库存显示到页面上去，而不是说等了很长时间，库存才反应到页面上去</p>
<p>时效性要求不高的数据：商品的基本信息（名称、颜色、版本、规格参数，等等）</p>
<p>时效性要求不高的数据，就还好，比如说你现在改变了商品的名称，稍微晚个几分钟反应到商品页面上，也还能接受</p>
<p>商品价格/库存等时效性要求高的数据，而且种类较少，采取相关的服务系统每次发生了变更的时候，直接采取数据库和redis缓存双写的方案，这样缓存的时效性最高</p>
<p>商品基本信息等时效性不高的数据，而且种类繁多，来自多种不同的系统，采取MQ异步通知的方式，写一个数据生产服务，监听MQ消息，然后异步拉取服务的数据，更新tomcat jvm缓存+redis缓存</p>
<p>nginx+lua脚本做页面动态生成的工作，每次请求过来，优先从nginx本地缓存中提取各种数据，结合页面模板，生成需要的页面</p>
<p>如果nginx本地缓存过期了，那么就从nginx到redis中去拉取数据，更新到nginx本地</p>
<p>如果redis中也被LRU算法清理掉了，那么就从nginx走http接口到后端的服务中拉取数据，数据生产服务中，现在本地tomcat里的jvm堆缓存中找，ehcache，如果也被LRU清理掉了，那么就重新发送请求到源头的服务中去拉取数据，然后再次更新tomcat堆内存缓存+redis缓存，并返回数据给nginx，nginx缓存到本地</p>
<p>2、多级缓存架构中每一层的意义</p>
<p>nginx本地缓存，抗的是热数据的高并发访问，一般来说，商品的购买总是有热点的，比如每天购买iphone、nike、海尔等知名品牌的东西的人，总是比较多的</p>
<p>这些热数据，利用nginx本地缓存，由于经常被访问，所以可以被锁定在nginx的本地缓存内</p>
<p>大量的热数据的访问，就是经常会访问的那些数据，就会被保留在nginx本地缓存内，那么对这些热数据的大量访问，就直接走nginx就可以了</p>
<p>那么大量的访问，直接就可以走到nginx就行了，不需要走后续的各种网络开销了</p>
<p>redis分布式大规模缓存，抗的是很高的离散访问，支撑海量的数据，高并发的访问，高可用的服务</p>
<p>redis缓存最大量的数据，最完整的数据和缓存，1T+数据; 支撑高并发的访问，QPS最高到几十万; 可用性，非常好，提供非常稳定的服务</p>
<p>nginx本地内存有限，也就能cache住部分热数据，除了各种iphone、nike等热数据，其他相对不那么热的数据，可能流量会经常走到redis那里</p>
<p>利用redis cluster的多master写入，横向扩容，1T+以上海量数据支持，几十万的读写QPS，99.99%高可用性，那么就可以抗住大量的离散访问请求</p>
<p>tomcat jvm堆内存缓存，主要是抗redis大规模灾难的，如果redis出现了大规模的宕机，导致nginx大量流量直接涌入数据生产服务，那么最后的tomcat堆内存缓存至少可以再抗一下，不至于让数据库直接裸奔</p>
<p>同时tomcat jvm堆内存缓存，也可以抗住redis没有cache住的最后那少量的部分缓存</p>
<h3 id="Cache-Aside-Pattern缓存-数据库读写模式的分析"><a href="#Cache-Aside-Pattern缓存-数据库读写模式的分析" class="headerlink" title="Cache Aside Pattern缓存 + 数据库读写模式的分析"></a>Cache Aside Pattern缓存 + 数据库读写模式的分析</h3><p>最经典的缓存+数据库读写的模式，cache aside pattern</p>
<p>1、Cache Aside Pattern</p>
<p>（1）读的时候，先读缓存，缓存没有的话，那么就读数据库，然后取出数据后放入缓存，同时返回响应</p>
<p>（2）更新的时候，先删除缓存，然后再更新数据库</p>
<p>2、为什么是删除缓存，而不是更新缓存呢？</p>
<p>原因很简单，很多时候，复杂点的缓存的场景，因为缓存有的时候，不简单是数据库中直接取出来的值</p>
<p>商品详情页的系统，修改库存，只是修改了某个表的某些字段，但是要真正把这个影响的最终的库存计算出来，可能还需要从其他表查询一些数据，然后进行一些复杂的运算，才能最终计算出</p>
<p>现在最新的库存是多少，然后才能将库存更新到缓存中去</p>
<p>比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据，并进行运算，才能计算出缓存最新的值的</p>
<p>更新缓存的代价是很高的</p>
<p>是不是说，每次修改数据库的时候，都一定要将其对应的缓存去跟新一份？也许有的场景是这样的，但是对于比较复杂的缓存数据计算的场景，就不是这样了</p>
<p>如果你频繁修改一个缓存涉及的多个表，那么这个缓存会被频繁的更新，频繁的更新缓存</p>
<p>但是问题在于，这个缓存到底会不会被频繁访问到？？？</p>
<p>举个例子，一个缓存涉及的表的字段，在1分钟内就修改了20次，或者是100次，那么缓存跟新20次，100次; 但是这个缓存在1分钟内就被读取了1次，有大量的冷数据</p>
<p>28法则，黄金法则，20%的数据，占用了80%的访问量</p>
<p>实际上，如果你只是删除缓存的话，那么1分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低</p>
<p>每次数据过来，就只是删除缓存，然后修改数据库，如果这个缓存，在1分钟内只是被访问了1次，那么只有那1次，缓存是要被重新计算的，用缓存才去算缓存</p>
<p>其实删除缓存，而不是更新缓存，就是一个lazy计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算</p>
<p>mybatis，hibernate，懒加载，思想</p>
<p>查询一个部门，部门带了一个员工的list，没有必要说每次查询部门，都里面的1000个员工的数据也同时查出来啊</p>
<p>80%的情况，查这个部门，就只是要访问这个部门的信息就可以了</p>
<p>先查部门，同时要访问里面的员工，那么这个时候只有在你要访问里面的员工的时候，才会去数据库里面查询1000个员工</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/28/网络零散知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen ZeTao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/weixin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddd `Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/28/网络零散知识/" itemprop="url">网络零散知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-28T09:57:00+08:00">
                2019-09-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><p>（1）TCP是面向连接的，udp是无连接的即发送数据前不需要先建立链接。</p>
<p>（2）TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。 并且因为tcp可靠，面向连接，不会丢失数据因此适合大数据量的交换。</p>
<p>（3）TCP是面向字节流，UDP面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如IP电话和视频会议等）。</p>
<p>（4）TCP只能是1对1的，UDP支持1对1,1对多。</p>
<p>（5）TCP的首部较大为20字节，而UDP只有8字节。</p>
<p>（6）TCP是面向连接的可靠性传输，而UDP是不可靠的。</p>
<ul>
<li>基于TCP的应用层协议有：POP3、SMTP（简单邮件传输协议）、TELNET（远程登陆协议）、HTTP（超文本传输协议）、HTTPS（超文本传输安全协议）、FTP（文件传输协议）</li>
<li>基于UDP的应用层协议：TFTP（简单文件传输协议）、RIP（路由信息协议）、DHCP（动态主机设置协议）、BOOTP（引导程序协议，DHCP的前身）、IGMP（Internet组管理协议）</li>
<li>基于TCP和UDP协议：DNS（域名系统）、ECHO（回绕协议）</li>
</ul>
<p>以下内容来自：公众号 前端指南，作者 前端指南</p>
<h2 id="简述-http-1-1-与-http-1-0-的区别"><a href="#简述-http-1-1-与-http-1-0-的区别" class="headerlink" title="简述 http 1.1 与 http 1.0 的区别"></a>简述 http 1.1 与 http 1.0 的区别</h2><ul>
<li>http 1.0 对于每个连接都得建立一次连接, 一次只能传送一个请求和响应, 请求就会关闭, http1.0 没有 Host 字段</li>
<li>而 http1.1 在同一个连接中可以传送多个请求和响应, 多个请求可以重叠和同时进行, http1.1 必须有 host 字段</li>
<li>http1.1 中引入了 ETag 头, 它的值 entity tag 可以用来唯一的描述一个资源. 请求消息中可以使用 If-None-Match 头域来匹配资源的 entitytag 是否有变化</li>
<li>http1.1 新增了 Cache-Control 头域(消息请求和响应请求都可以使用), 它支持一个可扩展的指令子集</li>
<li>http1.0 中只定义了 16 个状态响应码, 对错误或警告的提示不够具体. http1.1 引入了一个 Warning 头域, 增加对错误或警告信息的描述. 且新增了 24 个状态响应码</li>
</ul>
<h2 id="从输入-URL-到页面加载发生了什么-必考"><a href="#从输入-URL-到页面加载发生了什么-必考" class="headerlink" title="从输入 URL 到页面加载发生了什么[必考]"></a>从输入 URL 到页面加载发生了什么[必考]</h2><p>总体来说分为以下几个过程:</p>
<ul>
<li>DNS 解析</li>
<li>TCP 连接</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ul>
<h2 id="Socket-连接与-HTTP-连接的联系与区别"><a href="#Socket-连接与-HTTP-连接的联系与区别" class="headerlink" title="Socket 连接与 HTTP 连接的联系与区别"></a>Socket 连接与 HTTP 连接的联系与区别</h2><p>由于通常情况下 Socket 连接就是 TCP 连接，因此 Socket 连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。</p>
<p>而 HTTP 连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。</p>
<p>很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是 Socket 连接，服务器就可以直接将数据传送给客户端;若双方建立的是 HTTP 连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。</p>
<h2 id="Http2-0-与-http1-x-相比有什么优点-常考"><a href="#Http2-0-与-http1-x-相比有什么优点-常考" class="headerlink" title="Http2.0 与 http1.x 相比有什么优点(常考)"></a>Http2.0 与 http1.x 相比有什么优点(常考)</h2><ul>
<li>二进制格式:http1.x 是文本协议，而 http2.0 是二进制以帧为基本单位，是一个二进制协议，一帧中除了包含数据外同时还包含该帧的标识：Stream Identifier，即标识了该帧属于哪个 request,使得网络传输变得十分灵活。</li>
<li>多路复用: 一个很大的改进，原先 http1.x 一个连接一个请求的情况有比较大的局限性，也引发了很多问题，如建立多个连接的消耗以及效率问题。</li>
<li><ul>
<li>http1.x 为了解决效率问题，可能会尽量多的发起并发的请求去加载资源，然而浏览器对于同一域名下的并发请求有限制，而优化的手段一般是将请求的资源放到不同的域名下来突破这种限制。</li>
<li>而 http2.0 支持的多路复用可以很好的解决这个问题，多个请求共用一个 TCP 连接，多个请求可以同时在这个 TCP 连接上并发，一个是解决了建立多个 TCP 连接的消耗问题，一个也解决了效率的问题。那么是什么原理支撑多个请求可以在一个 TCP 连接上并发呢？基本原理就是上面的二进制分帧，因为每一帧都有一个身份标识，所以多个请求的不同帧可以并发的无序发送出去，在服务端会根据每一帧的身份标识，将其整理到对应的 request 中。</li>
</ul>
</li>
<li>header 头部压缩:主要是通过压缩 header 来减少请求的大小，减少流量消耗，提高效率。因为之前存在一个问题是，每次请求都要带上 header，而这个 header 中的数据通常是一层不变的。</li>
<li>支持服务端推送</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/26/查漏补缺/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen ZeTao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/weixin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddd `Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/26/查漏补缺/" itemprop="url">查漏补缺</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-26T15:35:49+08:00">
                2019-09-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  33
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>自19.09.26开始，对复习的知识遗漏点进行总结</strong></p>
<h2 id="19-09-26"><a href="#19-09-26" class="headerlink" title="19.09.26"></a>19.09.26</h2><h1 id="JAVA锁"><a href="#JAVA锁" class="headerlink" title="JAVA锁"></a>JAVA锁</h1><p>Java SE1.6为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。<strong>锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</strong></p>
<h3 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h3><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁，读锁，写锁等，都是在做操作之前先上锁。JAVA中synchronize和ReentrantLock等独占锁就是悲观锁思想的实现。</p>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>总是假设最好的情况，每次拿数据都认为别人不会修改，所以不会上锁。<strong>但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。</strong></p>
<p>乐观锁适用于多读的应用类型，这样可以提高吞吐量。</p>
<p><strong>java中的4种锁，分别是重量级锁，自旋锁，轻量级锁和偏向锁。重量级锁是悲观锁的一种，自旋锁，轻量级锁和偏向锁属于乐观锁。</strong></p>
<h5 id="乐观锁常见的两种实现方式"><a href="#乐观锁常见的两种实现方式" class="headerlink" title="乐观锁常见的两种实现方式"></a>乐观锁常见的两种实现方式</h5><blockquote>
<p><strong>乐观锁一般会使用版本号机制或CAS算法实现。</strong></p>
</blockquote>
<h4 id="1-版本号机制"><a href="#1-版本号机制" class="headerlink" title="1. 版本号机制"></a>1. 版本号机制</h4><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
<p><strong>举一个简单的例子：</strong> 假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。</p>
<ol>
<li>操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。</li>
<li>在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。</li>
<li>操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。</li>
<li>操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</li>
</ol>
<p>这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</p>
<h4 id="2-简单回顾一下CAS算法"><a href="#2-简单回顾一下CAS算法" class="headerlink" title="2.简单回顾一下CAS算法"></a>2.简单回顾一下CAS算法</h4><p><strong>CAS算法</strong> 即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数</p>
<ul>
<li>需要读写的内存值 V</li>
<li>进行比较的值 A</li>
<li>拟写入的新值 B</li>
</ul>
<p>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</p>
<h3 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a>乐观锁的缺点</h3><blockquote>
<p>ABA 问题是乐观锁一个常见的问题</p>
</blockquote>
<h4 id="1-ABA-问题"><a href="#1-ABA-问题" class="headerlink" title="1 ABA 问题"></a>1 ABA 问题</h4><p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 <strong>“ABA”问题。</strong></p>
<p>JDK 1.5 以后的 <code>AtomicStampedReference 类</code>就提供了此种能力，其中的 <code>compareAndSet 方法</code>就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<h4 id="2-循环时间长开销大"><a href="#2-循环时间长开销大" class="headerlink" title="2 循环时间长开销大"></a>2 循环时间长开销大</h4><p><strong>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。</strong> 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>
<h4 id="3-只能保证一个共享变量的原子操作"><a href="#3-只能保证一个共享变量的原子操作" class="headerlink" title="3 只能保证一个共享变量的原子操作"></a>3 只能保证一个共享变量的原子操作</h4><p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了<code>AtomicReference类</code>来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用<code>AtomicReference类</code>把多个共享变量合并成一个共享变量来操作。</p>
<h3 id="什么是自旋锁？"><a href="#什么是自旋锁？" class="headerlink" title="什么是自旋锁？"></a>什么是自旋锁？</h3><p>自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。</p>
<p>获取锁的线程一直处于活跃状态，但是并没有执行任何有效的任务，使用这种锁会造成<a href="https://en.wikipedia.org/wiki/Busy_waiting" target="_blank" rel="noopener">busy-waiting</a>。</p>
<p>它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。</p>
<h3 id="Java如何实现自旋锁？"><a href="#Java如何实现自旋锁？" class="headerlink" title="Java如何实现自旋锁？"></a>Java如何实现自旋锁？</h3><p>下面是个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; cas = <span class="keyword">new</span> AtomicReference&lt;Thread&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 利用CAS</span></span><br><span class="line">        <span class="keyword">while</span> (!cas.compareAndSet(<span class="keyword">null</span>, current)) &#123;</span><br><span class="line">            <span class="comment">// DO nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        cas.compareAndSet(current, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<p>lock（)方法利用的CAS，当第一个线程A获取锁的时候，能够成功获取到，不会进入while循环，如果此时线程A没有释放锁，另一个线程B又来获取锁，此时由于不满足CAS，所以就会进入while循环，不断判断是否满足CAS，直到A线程调用unlock方法释放了该锁。</p>
<h3 id="自旋锁存在的问题"><a href="#自旋锁存在的问题" class="headerlink" title="自旋锁存在的问题"></a>自旋锁存在的问题</h3><ol>
<li>如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。使用不当会造成CPU使用率极高。</li>
<li>上面Java实现的自旋锁不是公平的，即无法满足等待时间最长的线程优先获取锁。不公平的锁就会存在“线程饥饿”问题。</li>
</ol>
<h3 id="自旋锁的优点"><a href="#自旋锁的优点" class="headerlink" title="自旋锁的优点"></a>自旋锁的优点</h3><ol>
<li><p>自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快</p>
</li>
<li><p>非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）</p>
</li>
</ol>
<h3 id="TicketLock主要解决的是公平性的问题。"><a href="#TicketLock主要解决的是公平性的问题。" class="headerlink" title="TicketLock主要解决的是公平性的问题。"></a>TicketLock主要解决的是公平性的问题。</h3><p>思路：每当有线程获取锁的时候，就给该线程分配一个递增的id，我们称之为排队号，同时，锁对应一个服务号，每当有线程释放锁，服务号就会递增，此时如果服务号与某个线程排队号一致，那么该线程就获得锁，由于排队号是递增的，所以就保证了最先请求获取锁的线程可以最先获取到锁，就实现了公平性。</p>
<p>可以想象成银行办理业务排队，排队的每一个顾客都代表一个需要请求锁的线程，而银行服务窗口表示锁，每当有窗口服务完成就把自己的服务号加一，此时在排队的所有顾客中，只有自己的排队号与服务号一致的才可以得到服务。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>Java偏向锁(Biased Locking)是Java6引入的一项多线程优化。<br>偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。<br><strong>如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。</strong></p>
<p>它通过消除资源无竞争情况下的同步原语，进一步提高了程序的运行性能。</p>
<h4 id="偏向锁的实现"><a href="#偏向锁的实现" class="headerlink" title="偏向锁的实现"></a>偏向锁的实现</h4><p>偏向锁获取过程：</p>
<ol>
<li>访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，确认为可偏向状态。</li>
<li>如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。</li>
<li>如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行5；如果竞争失败，执行4。</li>
<li>如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。（撤销偏向锁的时候会导致stop the word）</li>
<li>执行同步代码。</li>
</ol>
<p>注意：第四步中到达安全点safepoint会导致stop the word，时间很短。</p>
<h4 id="偏向锁的释放："><a href="#偏向锁的释放：" class="headerlink" title="偏向锁的释放："></a>偏向锁的释放：</h4><p>偏向锁的撤销在上述第四步骤中有提到。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，<strong>线程不会主动去释放偏向锁。</strong>偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p>
<h4 id="偏向锁的适用场景"><a href="#偏向锁的适用场景" class="headerlink" title="偏向锁的适用场景"></a>偏向锁的适用场景</h4><p>始终只有一个线程在执行同步块，在它没有执行完释放锁之前，没有其它线程去执行同步块，在锁无竞争的情况下使用，一旦有了竞争就升级为轻量级锁，升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致stop the word操作；<br>在有锁的竞争时，偏向锁会多做很多额外操作，尤其是撤销偏向所的时候会导致进入安全点，安全点会导致stw，导致性能下降，这种情况下应当禁用； </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作。同时我们可以发现，很多对象锁的锁定状态只会持续很短的一段时间，例如整数的自加操作，在很短的时间内阻塞并唤醒线程显然不值得，为此引入了自旋锁。</p>
<p>所谓“自旋”，就是让线程去执行一个无意义的循环，循环结束后再去重新竞争锁，如果竞争不到继续循环，循环过程中线程会一直处于running状态，但是基于JVM的线程调度，会出让时间片，所以其他线程依旧有申请锁和释放锁的机会。</p>
<p>自旋锁省去了阻塞锁的时间空间（队列的维护等）开销，但是长时间自旋就变成了“忙式等待”，忙式等待显然还不如阻塞锁。所以自旋的次数一般控制在一个范围内，例如10,100等，在超出这个范围后，自旋锁会升级为阻塞锁。（即从轻量级锁转变为重量级锁）</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>加锁</p>
<p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。<strong>然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，则自旋获取锁，当自旋获取锁仍然失败时，表示存在其他线程竞争锁(两条或两条以上的线程竞争同一个锁)，则轻量级锁会膨胀成重量级锁。</strong></p>
<p>解锁</p>
<p><strong>轻量级解锁时，会使用原子的CAS操作来将Displaced Mark Word替换回到对象头，如果成功，则表示同步过程已完成。</strong>如果失败，表示有其他线程尝试过获取该锁，则要在释放锁的同时唤醒被挂起的线程。</p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>重量锁在JVM中又叫对象监视器（Monitor），它很像C中的Mutex，除了具备Mutex(0|1)互斥的功能，它还负责实现了Semaphore(信号量)的功能，也就是说它至少包含一个竞争锁的队列，和一个信号阻塞队列（wait队列），前者负责做互斥，后一个用于做线程同步。</p>
<p><strong>如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS都不做了。</strong></p>
<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><h2 id="JDk7版本"><a href="#JDk7版本" class="headerlink" title="JDk7版本"></a>JDk7版本</h2><ul>
<li><p>ConcurrentHashMap的锁分段技术可有效提升并发访问率</p>
<p>HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，假如容器中有多把锁，每一个把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术。首先将数据分为一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能够别其他数据访问。</p>
</li>
</ul>
<h3 id="ConcurrentHashMap的结构"><a href="#ConcurrentHashMap的结构" class="headerlink" title="ConcurrentHashMap的结构"></a>ConcurrentHashMap的结构</h3><p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁（ReentrantLock），在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储键值对数据。Segment的结构和HashMap类似，是一种数组和链表结构。一个Segment里包含一个HashEntry数组，每个HashEntry里是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁。</p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>JDK1.7的ConcurrentHashMap的get操作是不加锁的，因为在每个Segment中定义的HashEntry数组和在每个HashEntry中定义的value和next HashEntry节点都是volatile类型的，volatile类型的变量可以保证其在多线程之间的可见性，因此可以被多个线程同时读，从而不用加锁。而其get操作步骤也比较简单，定位Segment –&gt; 定位HashEntry –&gt; 通过getObjectVolatile()方法获取指定偏移量上的HashEntry –&gt; 通过循环遍历链表获取对应值。</p>
<p>定位Segment：(((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE</p>
<p>定位HashEntry：(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE</p>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>在Segment的put方法中，首先需要调用tryLock()方法获取锁，然后通过hash算法定位到对应的HashEntry，然后遍历整个链表，如果查到key值，则直接插入元素即可；而如果没有查询到对应的key，则需要调用rehash()方法对Segment中保存的table进行扩容，扩容为原来的2倍，并在扩容之后插入对应的元素。插入一个key/value对后，需要将统计Segment中元素个数的count属性加1。最后，插入成功之后，需要使用unLock()释放锁。</p>
<h2 id="JDK8版本"><a href="#JDK8版本" class="headerlink" title="JDK8版本"></a>JDK8版本</h2><p>在JDK1.7之前，ConcurrentHashMap是通过分段锁机制来实现的，所以其最大并发度受Segment的个数限制。因此，在JDK1.8中，ConcurrentHashMap的实现原理摒弃了这种设计，而是选择了与HashMap类似的数组+链表+红黑树的方式实现，而加锁则采用CAS和synchronized实现。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>JDK1.8的ConcurrentHashMap数据结构比JDK1.7之前的要简单的多，其使用的是HashMap一样的数据结构：数组+链表+红黑树。ConcurrentHashMap中包含一个table数组，其类型是一个Node数组；而Node是一个继承自Map.Entry&lt;K, V&gt;的链表，而当这个链表结构中的数据大于8，则将数据结构升级为TreeBin类型的红黑树结构。另外，</p>
<p>JDK1.8中的ConcurrentHashMap中还包含一个重要属性sizeCtl，其是一个控制标识符，不同的值代表不同的意思：其为0时，表示hash表还未初始化，而为正数时这个数值表示初始化或下一次扩容的大小，相当于一个阈值；即如果hash表的实际大小&gt;=sizeCtl，则进行扩容，默认情况下其是当前ConcurrentHashMap容量的0.75倍；而如果sizeCtl为-1，表示正在进行初始化操作；而为-N时，则表示有N-1个线程正在进行扩容。</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内部类node里的val，next都使用了volatile关键字</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V val;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 使用node数组， 也是用volatile数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>
<p><strong>get方法同1.7的一致，由于node都是使用volatile修饰，在get的源码实现中，并不用加锁。</strong></p>
<h2 id="SQL注入简介"><a href="#SQL注入简介" class="headerlink" title="SQL注入简介"></a>SQL注入简介</h2><p>SQL注入是网站存在最多也是最简单的漏洞，主要原因是程序员在开发用户和数据库交互的系统时，没有对用户输入的字符串进行过滤，转义，限制或处理不严谨，导致用户可以通过输入精心构造的字符串去非法获取到数据库中的数据。</p>
<h3 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h3><p>一般用户登录用的SQL语句为：SELECT <em> FROM user WHERE username=’admin’ AND password=’passwd’，此处admin和passwd分别为用户输入的用户名和密码，如果程序员没有对用户输入的用户名和密码做处理，就可以构造万能密码成功绕过登录验证，如用户输入<strong>‘or 1#</strong>,SQL语句将变为：SELECT </em> FROM user WHERE username=’’or 1#’ AND password=’’，‘’or 1为TRUE，#注释掉后面的内容，所以查询语句可以正确执行。</p>
<h3 id="mybatis是如何防止SQL注入的"><a href="#mybatis是如何防止SQL注入的" class="headerlink" title="mybatis是如何防止SQL注入的"></a>mybatis是如何防止SQL注入的</h3><h3 id="1、首先看一下下面两个sql语句的区别："><a href="#1、首先看一下下面两个sql语句的区别：" class="headerlink" title="1、首先看一下下面两个sql语句的区别："></a>1、首先看一下下面两个sql语句的区别：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id="selectByNameAndPassword" parameterType="java.util.Map" resultMap="BaseResultMap"&gt;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, username, <span class="keyword">password</span>, <span class="keyword">role</span></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">where</span> username = <span class="comment">#&#123;username,jdbcType=VARCHAR&#125;</span></span><br><span class="line"><span class="keyword">and</span> <span class="keyword">password</span> = <span class="comment">#&#123;password,jdbcType=VARCHAR&#125;</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id="selectByNameAndPassword" parameterType="java.util.Map" resultMap="BaseResultMap"&gt;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, username, <span class="keyword">password</span>, <span class="keyword">role</span></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">where</span> username = $&#123;username,jdbcType=<span class="built_in">VARCHAR</span>&#125;</span><br><span class="line"><span class="keyword">and</span> <span class="keyword">password</span> = $&#123;<span class="keyword">password</span>,jdbcType=<span class="built_in">VARCHAR</span>&#125;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>
<p><strong>mybatis中的#和$的区别：</strong></p>
<p>1、#将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。<br>如：where username=#{username}，如果传入的值是111,那么解析成sql时的值为where username=”111”, 如果传入的值是id，则解析成的sql为where username=”id”.　<br>2、$将传入的数据直接显示生成在sql中。<br>如：where username=${username}，如果传入的值是111,那么解析成sql时的值为where username=111；<br>如果传入的值是;drop table user;，则解析成的sql为：select id, username, password, role from user where username=;drop table user;<br>3、#方式能够很大程度防止sql注入，$方式无法防止Sql注入。<br>4、$方式一般用于传入数据库对象，例如传入表名.<br>5、一般能用#的就别用$，若不得不使用“${xxx}”这样的参数，要手工地做好过滤工作，来防止sql注入攻击。<br>6、在MyBatis中，“${xxx}”这样格式的参数会直接参与SQL编译，从而不能避免注入攻击。但涉及到动态表名和列名时，只能使用“${xxx}”这样的参数格式。所以，这样的参数需要我们在代码中手工进行处理来防止注入。<br>【结论】在编写MyBatis的映射语句时，尽量采用“#{xxx}”这样的格式。若不得不使用“${xxx}”这样的参数，要手工地做好过滤工作，来防止SQL注入攻击。</p>
<h3 id="2、什么是sql注入"><a href="#2、什么是sql注入" class="headerlink" title="2、什么是sql注入"></a>2、什么是sql注入</h3><p>　　<a href="https://en.wikipedia.org/wiki/SQL_injection" target="_blank" rel="noopener"> sql注入解释</a>：是一种代码注入技术，用于攻击数据驱动的应用，恶意的SQL语句被插入到执行的实体字段中（例如，为了转储数据库内容给攻击者）</p>
<p>　　<strong>SQL**</strong>注入<strong>，大家都不陌生，是一种常见的攻击方式。</strong>攻击者<strong>在界面的表单信息或URL上输入一些奇怪的SQL片段（例如“or ‘1’=’1’”这样的语句），有可能入侵</strong>参数检验不足<strong>的应用程序。所以，在我们的应用中需要做一些工作，来防备这样的攻击方式。在一些安全性要求很高的应用中（比如银行软件），经常使用将</strong>SQL<strong>**语句</strong>全部替换为<strong>存储过程</strong>这样的方式，来防止SQL注入。这当然是<strong>一种很安全的方式</strong>，但我们平时开发中，可能不需要这种死板的方式。</p>
<h3 id="3、mybatis是如何做到防止sql注入的"><a href="#3、mybatis是如何做到防止sql注入的" class="headerlink" title="3、mybatis是如何做到防止sql注入的"></a>3、mybatis是如何做到防止sql注入的</h3><p>　　<a href="https://mybatis.github.io/mybatis-3/" target="_blank" rel="noopener">MyBatis</a>框架作为一款半自动化的持久层框架，其SQL语句都要我们自己手动编写，这个时候当然需要防止SQL注入。其实，MyBatis的SQL是一个具有“<strong>输入+输出</strong>”的功能，类似于函数的结构，参考上面的两个例子。其中，parameterType表示了输入的参数类型，resultType表示了输出的参数类型。回应上文，如果我们想防止SQL注入，理所当然地要在输入参数上下功夫。上面代码中使用 <strong>#</strong> 的即输入参数在SQL中拼接的部分，传入参数后，打印出执行的SQL语句，会看到SQL是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id, username, password, role from user where username=? and password=?</span><br></pre></td></tr></table></figure>
<p>　　不管输入什么参数，打印出的SQL都是这样的。这是因为MyBatis启用了预编译功能，在SQL执行前，会先将上面的SQL发送给数据库进行编译；执行时，直接使用编译好的SQL，替换占位符“?”就可以了。因为SQL注入只能对编译过程起作用，所以这样的方式就很好地避免了SQL注入的问题。</p>
<p>　　【底层实现原理】MyBatis是如何做到SQL预编译的呢？其实在框架底层，是JDBC中的PreparedStatement类在起作用，PreparedStatement是我们很熟悉的Statement的子类，它的对象包含了编译好的SQL语句。这种“准备好”的方式不仅能提高安全性，而且在多次执行同一个SQL时，能够提高效率。原因是SQL已编译好，再次执行时无需再编译。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//安全的，预编译了的</span><br><span class="line">Connection conn = getConn();//获得连接</span><br><span class="line">String sql = &quot;select id, username, password, role from user where id=?&quot;; //执行sql前会预编译号该条语句</span><br><span class="line">PreparedStatement pstmt = conn.prepareStatement(sql); </span><br><span class="line">pstmt.setString(1, id); </span><br><span class="line">ResultSet rs=pstmt.executeUpdate(); </span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//不安全的，没进行预编译</span><br><span class="line">private String getNameByUserId(String userId) &#123;</span><br><span class="line">    Connection conn = getConn();//获得连接</span><br><span class="line">    String sql = &quot;select id,username,password,role from user where id=&quot; + id;</span><br><span class="line">    //当id参数为&quot;3;drop table user;&quot;时，执行的sql语句如下:</span><br><span class="line">    //select id,username,password,role from user where id=3; drop table user;  </span><br><span class="line">    PreparedStatement pstmt =  conn.prepareStatement(sql);</span><br><span class="line">    ResultSet rs=pstmt.executeUpdate();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【 <strong>结论</strong>：】</p>
<table>
<thead>
<tr>
<th>#{}：相当于JDBC中的PreparedStatement</th>
</tr>
</thead>
<tbody>
<tr>
<td>${}：是输出变量的值</td>
</tr>
</tbody>
</table>
<p>简单说，#{}是经过预编译的，是安全的；${}是未经过预编译的，仅仅是取变量的值，是非安全的，存在SQL注入。<br>如果我们order by语句后用了${}，那么不做任何处理的时候是存在SQL注入危险的。你说怎么防止，那我只能悲惨的告诉你，你得手动处理过滤一下输入的内容。如判断一下输入的参数的长度是否正常（注入语句一般很长），更精确的过滤则可以查询一下输入的参数是否在预期的参数集合中。</p>
<p>作者：<a href="http://www.cnblogs.com/mmzs/" target="_blank" rel="noopener">淼淼之森</a></p>
<p>### </p>
<h2 id="19-09-27"><a href="#19-09-27" class="headerlink" title="19.09.27"></a>19.09.27</h2><p><a href="https://blog.csdn.net/a745233700/article/details/80977133" target="_blank" rel="noopener">mybatis面试题总结</a></p>
<p><a href="https://blog.csdn.net/a745233700/article/details/80977133" target="_blank" rel="noopener">Spring常见面试</a></p>
<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>
<p><strong>容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的。虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。因此容器的隔离级别会稍低一些。</strong></p>
<p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>
<h1 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h1><h3 id="区分认证-Authentication-和授权-Authorization"><a href="#区分认证-Authentication-和授权-Authorization" class="headerlink" title="区分认证 (Authentication) 和授权 (Authorization)"></a>区分认证 (Authentication) 和授权 (Authorization)</h3><p>这是一个绝大多数人都会混淆的问题。首先先从读音上来认识这两个名词，很多人都会把它俩的读音搞混，所以我建议你先先去查一查这两个单词到底该怎么读，他们的具体含义是什么。</p>
<p><strong>Authentication（认证）</strong> 是验证您的身份的凭据（例如用户名/用户ID和密码），通过这个凭据，系统得以知道你就是你，也就是说系统存在你这个用户。所以，Authentication 被称为身份/用户验证。</p>
<p><strong>Authorization（授权）</strong> 发生在 <strong>Authentication（认证）</strong>之后。授权嘛，光看意思大家应该就明白，它主要掌管我们访问系统的权限。比如有些特定资源只能具有特定权限的人才能访问比如admin，有些对系统资源操作比如删除、添加、更新只能特定人才具有。</p>
<p>这两个一般在我们的系统中被结合在一起使用，目的就是为了保护我们系统的安全性。</p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h3 id="为什么要用-redis-为什么要用缓存"><a href="#为什么要用-redis-为什么要用缓存" class="headerlink" title="为什么要用 redis/为什么要用缓存"></a>为什么要用 redis/为什么要用缓存</h3><p>主要从“高性能”和“高并发”这两点来看待这个问题。</p>
<p><strong>高性能：</strong></p>
<p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/54316596.jpg" alt></p>
<p><strong>高并发：</strong></p>
<p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/85146760.jpg" alt></p>
<h3 id="redis-设置过期时间"><a href="#redis-设置过期时间" class="headerlink" title="redis 设置过期时间"></a>redis 设置过期时间</h3><p>Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。如我们一般项目中的 token 或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。</p>
<p>我们 set key 的时候，都可以给一个 expire time，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的时间。</p>
<p>如果假设你设置了一批 key 只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？</p>
<p><strong>定期删除+惰性删除。</strong></p>
<p>通过名字大概就能猜出这两个删除方式的意思了。</p>
<ul>
<li><strong>定期删除</strong>：redis默认是每隔 100ms 就<strong>随机抽取</strong>一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！</li>
<li><strong>惰性删除</strong> ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！</li>
</ul>
<p>但是仅仅通过设置过期时间还是有问题的。我们想一下：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢？ <strong>redis 内存淘汰机制。</strong></p>
<h3 id="redis-持久化机制-怎么保证-redis-挂掉之后再重启数据可以进行恢复"><a href="#redis-持久化机制-怎么保证-redis-挂掉之后再重启数据可以进行恢复" class="headerlink" title="redis 持久化机制(怎么保证 redis 挂掉之后再重启数据可以进行恢复)"></a>redis 持久化机制(怎么保证 redis 挂掉之后再重启数据可以进行恢复)</h3><p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p>
<p>Redis不同于Memcached的很重一点就是，Redis支持持久化，而且支持两种不同的持久化操作。<strong>Redis的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file,AOF）</strong>。这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。</p>
<p><strong>快照（snapshotting）持久化（RDB）</strong></p>
<p>Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性能），还可以将快照留在原地以便重启服务器的时候使用。</p>
<p>快照持久化是Redis默认采用的持久化方式，在redis.conf配置文件中默认有此下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br></pre></td></tr></table></figure>
<p><strong>AOF（append-only file）持久化</strong></p>
<p>与快照持久化相比，AOF持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数开启：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>
<p>开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof。</p>
<p>在Redis的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步</span><br></pre></td></tr></table></figure>
<p>为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec选项 ，让Redis每秒同步一次AOF文件，Redis性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p>
<p><strong>Redis 4.0 对于持久化机制的优化</strong></p>
<p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p>
<p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p>
<h3 id="缓存雪崩和缓存穿透问题解决方案"><a href="#缓存雪崩和缓存穿透问题解决方案" class="headerlink" title="缓存雪崩和缓存穿透问题解决方案"></a>缓存雪崩和缓存穿透问题解决方案</h3><p><strong>缓存雪崩</strong></p>
<p>简介：缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>解决办法（中华石杉老师在他的视频中提到过，视频地址在最后一个问题中有提到）：</p>
<ul>
<li>事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。</li>
<li>事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL崩掉</li>
<li>事后：利用 redis 持久化机制保存的数据尽快恢复缓存</li>
</ul>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-25/6078367.jpg" alt="img"></p>
<p><strong>缓存穿透</strong></p>
<p>简介：一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>解决办法： 有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p><img src="https://images0.cnblogs.com/blog/288799/201408/241109342846403.jpg" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/10/计算机网络/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen ZeTao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/weixin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddd `Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/10/计算机网络/" itemprop="url">计算机网络</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-10T21:49:01+08:00">
                2019-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/复习/" itemprop="url" rel="index">
                    <span itemprop="name">复习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h2><h3 id="OSI参考模型结构包括以下7层：物理层，数据链路层，网络层，传输层，会话层，表示层和应用层。"><a href="#OSI参考模型结构包括以下7层：物理层，数据链路层，网络层，传输层，会话层，表示层和应用层。" class="headerlink" title="OSI参考模型结构包括以下7层：物理层，数据链路层，网络层，传输层，会话层，表示层和应用层。"></a>OSI参考模型结构包括以下7层：物理层，数据链路层，网络层，传输层，会话层，表示层和应用层。</h3><ol>
<li>物理层<br>实现比特流的透明传输，为数据链路层提供数据传输服务<br>物理层的数据传输单位是比特（bit）</li>
<li>数据链路层<br>数据链路层在物理层提供比特流传输的基础上，通过建立数据链路连接，采用差错控制与流量控制方法，使有差错的物理线路变成无差错的数据链路。<br>数据链路层的数据传输单位是帧。</li>
<li>网络层<br>网络层通过路由选择算法为分组通过通信子网选择适当的传输路径，实现流量控制，拥塞控制与网络互联的功能。<br>网络层的数据传输功能是分组。</li>
<li>传输层<br>传输层为分布在不同地理位置计算机的进程通信提供可靠的端-端连接与数据传输服务。<br>传输层的数据传输单元是报文。<h2 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h2><h3 id="TCP-IP起源"><a href="#TCP-IP起源" class="headerlink" title="TCP/IP起源"></a>TCP/IP起源</h3>目前TCP/IP已经成为公认的Internet工业标准与事实上的Internet协议标准。目前使用的TCP/IP是版本4，即IPv4。<h3 id="TCP-IP参考模型的层次"><a href="#TCP-IP参考模型的层次" class="headerlink" title="TCP/IP参考模型的层次"></a>TCP/IP参考模型的层次</h3><h4 id="主机-网络层"><a href="#主机-网络层" class="headerlink" title="主机-网络层"></a>主机-网络层</h4>与OSI参考模型的数据链路层和物理层对应。TCP/IP协议对主机-网络层并没有规定具体的协议。<h4 id="互联网络层（网络层）-IP"><a href="#互联网络层（网络层）-IP" class="headerlink" title="互联网络层（网络层）(IP)"></a>互联网络层（网络层）(IP)</h4>使用的是IP协议，IP是一种不可控，无连接的数据报传输服务协议，它提供的是一种“尽力而为”的服务。<h4 id="传输层（UDP，TCP）"><a href="#传输层（UDP，TCP）" class="headerlink" title="传输层（UDP，TCP）"></a>传输层（UDP，TCP）</h4>传输层定义两种不同的协议，传输控制层（Transport Control Protocol,TCP）与用户数据报协议（User Datagram Protocol，UDP）。<br>TCP是一种可靠的，面向连接，面向字节流的传输层协议。TCP提供比较完善的流量控制与拥塞控制功能。UDP是一种不可靠的，无连接的传输层协议。<h5 id="TCP（Transmisson-Control-Protocol）"><a href="#TCP（Transmisson-Control-Protocol）" class="headerlink" title="TCP（Transmisson Control Protocol）"></a>TCP（Transmisson Control Protocol）</h5>TCP 是面向连接的（需要先建立连接）；<br>每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是一对一；<br>TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；<br>TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；<br>面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。<h5 id="UDP（User-Datagram-Protocol）"><a href="#UDP（User-Datagram-Protocol）" class="headerlink" title="UDP（User Datagram Protocol）"></a>UDP（User Datagram Protocol）</h5>UDP 是无连接的；<br>UDP 是尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态；<br>UDP 是面向报文的；<br>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如直播，实时视频会议等）；<br>UDP 支持一对一、一对多、多对一和多对多的交互通信；<br>UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.单工数据传输只支持数据在一个方向上传输</span><br><span class="line">2.半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信；</span><br><span class="line">3.全双工数据通信允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。</span><br></pre></td></tr></table></figure>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层()"></a>应用层()</h4><p>应用层包括各种标准的网络应用协议，并且总有不断有新的协议加入。<br>TCP/IP应用层基本的协议主要有：</p>
<ol>
<li>远程登录协议（TELNET）</li>
<li>文件传输协议（File Transfer Protocol,FTP）</li>
<li>超文本传输协议（HTTP）</li>
<li>域名服务协议（DNS）<h2 id="IPv4协议的基本内容"><a href="#IPv4协议的基本内容" class="headerlink" title="IPv4协议的基本内容"></a>IPv4协议的基本内容</h2><h3 id="IP协议的主要特点"><a href="#IP协议的主要特点" class="headerlink" title="IP协议的主要特点"></a>IP协议的主要特点</h3></li>
<li>IP协议是一种无连接，不可靠的分组传送服务的协议。<ol>
<li>无连接意味着IP协议并不维护IP分组发送后的任何状态信息。每个分组的传输过程是相互独立的。</li>
<li>不可靠意味着IP协议不能保证每个IP分组都能够正确地，不丢失和顺序地到达目的主机。</li>
</ol>
</li>
<li>IP协议是点-点的网络层通信协议。<br>网络层需要在Internet中为通信的两个主机之间寻找一条路径，而这条路径通常是由多个路由器，点-点链路组成。因此，IP协议是针对源主机-路由器，路由器-路由器，路由器-目的主机之间的数据传输的点-点线路的网络层通信协议。<h3 id="IP地址的点分十进制的表示方法"><a href="#IP地址的点分十进制的表示方法" class="headerlink" title="IP地址的点分十进制的表示方法"></a>IP地址的点分十进制的表示方法</h3><strong>“网络号-主机号”的两级IP地址结构。</strong><br>IPv4的地址长度为32位，用点分十进制表示。通常采用x.x.x.x的格式来表示，每个x为8位，每个X的值为0~255.</li>
</ol>
<h3 id="标准IP地址的分类"><a href="#标准IP地址的分类" class="headerlink" title="标准IP地址的分类"></a>标准IP地址的分类</h3><ol>
<li>A类地址<br>A类地址网络号的第一位为0，其余的7位可以分配，<br>0   网络号（7位），主机号（24位）。A类地址共分为大小相同的128（2^7 = 128）,每一块的netID不同。</li>
<li>B类地址<br>B类地址的前两位为10，其余14位可以分配，可分配的网络号为2^14。B类地址的主机号长度为16位。<br>10 网络号（14） 主机号（16位）</li>
<li>C类地址<br>C类地址的前三位为110，其余的21位可以分配。主机号为8位。</li>
<li>D类地址<br>前4位为1110</li>
<li>E类地址<br>前5位为11110。<h3 id="特殊地址形式"><a href="#特殊地址形式" class="headerlink" title="特殊地址形式"></a>特殊地址形式</h3>特殊的IP地址包括以下四种类型</li>
<li>直接广播地址<br>在A类，B类与C类IP地址中，如果主机号是全1，那么这个地址为直接广播地址，路由器将这个分组以广播方式发送给特定网络的所有主机。</li>
<li>受限广播地址<br>32位网络号与主机号为全1的IP地址（255.255.255.255）为受限广播地址。它是用来将一个分组以广播方式发送给本网络中的所有主机。</li>
<li>“这个网络上的特定主机”地址<br>在A类，B类，C类IP地址中，如果网络号是全0（如0.0.0.25），该地址是这个网络上的特定主机地址。<h3 id="划分子网的三级地址结构"><a href="#划分子网的三级地址结构" class="headerlink" title="划分子网的三级地址结构"></a>划分子网的三级地址结构</h3>子网划分的基本思想是：借用主机号的一部分作为子网的子网号，划分出更多的子网IP地址。<h2 id="IPv6地址"><a href="#IPv6地址" class="headerlink" title="IPv6地址"></a>IPv6地址</h2>IPv6的128地址按每16位划分为一个位段，每个位段被转换为一个4位的十六进制数，并用冒号隔开，这种表示法称为“冒号十六进制表示法”。<br><strong>x:x:x:x:x:x:x:x</strong><h3 id="零压缩法"><a href="#零压缩法" class="headerlink" title="零压缩法"></a>零压缩法</h3>双冒号在一个地址中只能出现一次，<br>如何确定双冒号之间被压缩0的位数？可以数一下地址中还有多少个位段，然后用8减去这个数，再将结果乘以16。<br>例如，在地址FF02:3::5中有三个位段，可以根据公式计算：(8-3)*16=80,则 ::表示有80位的二进制数字0被压缩。2</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/10/事务/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen ZeTao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/weixin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddd `Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/10/事务/" itemprop="url">事务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-10T21:44:39+08:00">
                2019-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/事务/" itemprop="url" rel="index">
                    <span itemprop="name">事务</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  8
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h2><p><strong>事务就是一组原子性的sql,或者说一个独立的工作单元。事务就是说，要么MySql引擎会全部执行这一组SQL语句，要么全部都不执行。</strong></p>
<h3 id="事务的ACID"><a href="#事务的ACID" class="headerlink" title="事务的ACID"></a>事务的ACID</h3><p>Atomicity，原子性：一个事务必须保证其中的操作要么全部执行，要么全部回滚，不可能存在只执行了一部分这种情况出现。<br>Consistency，一致性：事务必须保证从一种一致性状态转换为另一种一致性状态。<br>Isolation,隔离性：事务互相隔离，在一个事务未执行完毕时，通常会保证其他Session无法看到这个事务的执行结果。<br>Durability，持久性：事务一旦commit，则数据就会保存下来，即使提交完之后系统崩溃，数据也不会丢失。</p>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>以下，我们来详细来说一说隔离性<br>我们都知道，事务控制的太严格，程序在并发訪问的情况下，会减少程序的性能。<br>所以。人们总是想让事务为性能做出让步。那么就分出了四种隔离级别：<br><strong>为未提交读、提交读、可重复度读、序列化。</strong><br><img src="https://www.javazhiyin.com/wp-content/uploads/2019/03/java1-1551760079.jpg" alt><br>可是。因为隔离界别限制的程度不同，那么就会产生脏读、不可反复读、幻读的情况。</p>
<ol>
<li>脏读：脏读就是指当一个事务正在訪问数据，而且对数据进行了改动，而这样的改动还没有提交到数据库中，这时。另外一个事务也訪问这个数据，然后使用了这个数据。</li>
<li>不可反复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时。另外一个事务也訪问该同一数据。那么，在第一个事务中的两次读数据之间，因为第二个事务的改动，那么第一个事务两次读到的的数据可能是不一样的。<br>这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可反复读。比如。一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改。<br>原始读取不可反复。假设仅仅有在作者所有完毕编写后编辑人员才干够读取文档，则能够避免该问题。</li>
<li>幻读:是指当事务不是独立运行时发生的一种现象，比如第一个事务对一个表中的数据进行了改动，这样的改动涉及到表中的所有数据行。同一时候。第二个事务也改动这个表中的数据。这样的改动是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有改动的数据行，就好象发生了幻觉一样。<br>比如。一个编辑人员更改作者提交的文档。但当生产部门将其更改内容合并到该文档的主复本时，发现作者已将未编辑的新材料加入到该文档中。<h3 id="事务并发下隔离级别的场景"><a href="#事务并发下隔离级别的场景" class="headerlink" title="事务并发下隔离级别的场景"></a>事务并发下隔离级别的场景</h3></li>
</ol>
<ul>
<li>未提交读<br>公司发工资了，领导把5000元打到singo的账号上，但是该事务并未提交，而singo正好去查看账户，发现工资已经到账，是5000元整。很高兴。但是不幸的是。领导发现发给singo的工资金额不正确。是2000元。于是迅速回滚了事务，改动金额后，将事务提交，最后singo实际的工资仅仅有2000元，singo空欢喜一场。<br>出现上述情况，即我们所说的脏读。两个并发的事务，“事务A：领导给singo发工资”、“事务B：singo查询工资账户”，事务B读取了事务A尚未提交的数据。<br>当隔离级别设置为Readuncommitted时，就可能出现脏读，怎样避免脏读。请看下一个隔离级别。</li>
<li>读提交<br>singo拿着工资卡去消费。系统读取到卡里确实有2000元。而此时她的老婆也正好在网上转账，把singo工资卡的2000元转到还有一账户，并在singo之前提交了事务，当singo扣款时，系统检查到singo的工资卡已经没有钱，扣款失败，singo十分纳闷，明明卡里有钱，为何……<br>出现上述情况，即我们所说的不可反复读。两个并发的事务，“事务A：singo消费”、“事务B：singo的老婆网上转账”。事务A事先读取了数据。事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。<br>当隔离级别设置为Readcommitted时，避免了脏读。可是可能会造成不可反复读。<br>大多数数据库的默认级别就是Readcommitted。比方Sql Server , Oracle。怎样解决不可反复读这一问题。请看下一个隔离级别。</li>
<li>反复读<br>当隔离级别设置为Repeatableread时。能够避免不可反复读。当singo拿着工资卡去消费时。一旦系统開始读取工资卡信息（即事务開始）。singo的老婆就不可能对该记录进行改动，也就是singo的老婆不能在此时转账。<br>尽管Repeatableread避免了不可反复读，但还有可能出现幻读。<br>singo的老婆工作在银行部门。她时常通过银行内部系统查看singo的信用卡消费记录。有一天，她正在查询到singo当月信用卡的总消费金额（select sum(amount) from transaction where month =本月）为80元。而singo此时正好在外面胡吃海塞后在收银台买单。消费1000元，即新增了一条1000元的消费记录（insert transaction… ）。并提交了事务。随后singo的老婆将singo当月信用卡消费的明细打印到A4纸上。却发现消费总额为1080元，singo的老婆非常诧异，以为出现了幻觉。幻读就这样产生了。<br>注：Mysql的默认隔离级别就是Repeatableread。</li>
<li>序列化<br>Serializable是最高的事务隔离级别。同一时候代价也花费最高，性能非常低，一般非常少使用，在该级别下，事务顺序运行，不仅能够避免脏读、不可反复读，还避免了幻像读。<h2 id="mysql开启事务"><a href="#mysql开启事务" class="headerlink" title="mysql开启事务"></a>mysql开启事务</h2>默认情况下，mysql每执行一条sql语句都是一条事务，自动提交。如果一条事务有多条sql语句需要执行，要开启一个新的事务<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">开启事务</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span></span><br><span class="line">....</span><br><span class="line">结束事务</span><br><span class="line"><span class="keyword">commit</span>/<span class="keyword">rollback</span></span><br><span class="line">或  </span><br><span class="line">通过AutoCommit设置事务开启或关闭</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">"autocommit"</span></span><br><span class="line"><span class="keyword">set</span> autocommit = <span class="number">0</span>; //0表示AutoCommit关闭</span><br><span class="line"><span class="keyword">set</span> autocommit = <span class="number">1</span>； //<span class="number">1</span>表示AutoCommit开启</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在执行SQL语句之前，先执行start transaction，这就开启了一个事务（事务的起点），然后可以去执行多条SQL语句，最后要结束事务，commit表示提交，即事务中的多条SQL语句所作出的影响会持久到数据库中，或者rollback，表示回滚到事务的起点，之前做的所有操作都被撤销了。</p>
<h2 id="jdbc-开启事务"><a href="#jdbc-开启事务" class="headerlink" title="jdbc 开启事务"></a>jdbc 开启事务</h2><p>默认自动提交事务，若要手动提交，则关闭事务。<br>在JDBC中处理事务，都是通过Connection完成的。<br>同一事务中所有的操作，都在使用同一个Connection对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">con.setAutoCommit(<span class="keyword">false</span>) 表示开启事务。</span><br><span class="line">...(进行多条sql)</span><br><span class="line">commit（）：提交结束事务。</span><br><span class="line">rollback（）：回滚结束事务。</span><br></pre></td></tr></table></figure></p>
<h4 id="附上jdbc代码练习"><a href="#附上jdbc代码练习" class="headerlink" title="附上jdbc代码练习"></a>附上jdbc代码练习</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">       Connection conn= <span class="keyword">null</span>;</span><br><span class="line">       String driver = <span class="string">"com.mysql.jdbc.Driver"</span>;</span><br><span class="line">       <span class="comment">//时区问题，serverTimezone=UTC</span></span><br><span class="line">       String url = <span class="string">"jdbc:mysql://localhost:3306/czt?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC"</span>;</span><br><span class="line">       String name = <span class="string">"root"</span>;</span><br><span class="line">       String password = <span class="string">"666666"</span>;</span><br><span class="line">       <span class="comment">//先获取链接驱动</span></span><br><span class="line">       Class.forName(driver);</span><br><span class="line">       String sql =<span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">       	<span class="comment">//通过driverManager获取链接</span></span><br><span class="line">           conn = DriverManager.getConnection(url, name, password);</span><br><span class="line">           <span class="keyword">if</span> (conn != <span class="keyword">null</span> )&#123;</span><br><span class="line">               System.out.println(<span class="string">"成功连接"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//通过链接，发送statement    preperStatement的区别是，可以预编译sql语句，再注入参数，</span></span><br><span class="line">           Statement statement = conn.createStatement();</span><br><span class="line">           sql = <span class="string">"create table student(NO char(20),name varchar(20),primary key(NO))"</span>;</span><br><span class="line">           <span class="comment">//返回影响行数</span></span><br><span class="line">           <span class="keyword">int</span> i = statement.executeUpdate(sql);</span><br><span class="line">           <span class="keyword">if</span> (i!=-<span class="number">1</span>)&#123;</span><br><span class="line">               System.out.println(<span class="string">"修改成功"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           conn.close();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h2 id="spring-开启事务"><a href="#spring-开启事务" class="headerlink" title="spring 开启事务"></a>spring 开启事务</h2><p><a href="https://juejin.im/post/5b00c52ef265da0b95276091" target="_blank" rel="noopener">spring 事务管理详解</a><br>在xml配置文件中<br><strong>第一步</strong>：配置事务管理器<br><strong>第二步</strong>：开启事务注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 第一步：配置事务管理器 (和配置文件方式一样)--&gt;</span><br><span class="line">	&lt;bean id=<span class="string">"dataSourceTransactionManager"</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span><br><span class="line">		&lt;!-- 注入dataSource --&gt;</span><br><span class="line">		&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 第二步： 开启事务注解 --&gt;</span><br><span class="line">	&lt;tx:annotation-driven transaction-manager=<span class="string">"dataSourceTransactionManager"</span> /&gt;</span><br><span class="line">	&lt;!-- 第三步 在方法所在类上加注解 --&gt;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/07/图/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen ZeTao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/weixin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddd `Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/07/图/" itemprop="url">图</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-07T10:15:41+08:00">
                2019-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>是大大大</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/07/位运算符/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen ZeTao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/weixin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddd `Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/07/位运算符/" itemprop="url">位运算符</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-07T09:19:44+08:00">
                2019-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="二进制的正负"><a href="#二进制的正负" class="headerlink" title="二进制的正负"></a>二进制的正负</h2><p>二进制的正负是从高位看，最高位如果1则是负数，如果是0则是正数。<br>如果负数单纯是把最高位变为1的话，在运算中会出现不是我们想要的值，所以引入了：<br><strong>原码，反码，补码。正数的原码，反码，补码都一样，负数的反码是对除了符号位（最高位）对原码取反，补码是对反码+1（最高位不变）</strong><br>-5的原码是               1000 0000 0000 0101<br>求出反码的是           1111 1111 1111 1010<br>求出补码是               1111 1111 1111 1011</p>
<h2 id="JAVA按位运算符"><a href="#JAVA按位运算符" class="headerlink" title="JAVA按位运算符"></a>JAVA按位运算符</h2><p>1、“与”、“位与”（&amp;）<br>按位“与”操作符，如果两个数的二进制，相同位数都是1，则该位结果是1，否则是0.<br>例1 5&amp;4<br>5的二进制是  0000 0000 0000 0101<br>4的二进制是  0000 0000 0000 0100<br>则结果是        0000 0000 0000 0100  转为十进制是4。<br>2、“或”、“位或”（|）<br>按位“或”操作符，如果两个数的二进制，相同位数有一个是1，则该位结果是1，否则是0<br>例2  5 | 4<br>5的二进制是  0000 0000 0000 0101<br>4的二进制是  0000 0000 0000 0100<br>则结果是        0000 0000 0000 0101  转为十进制是5。<br>3、“异或、“位异或”（^）<br>按位“异或”操作符，如果两个数的二进制，相同位数只有一个是1，则该位结果是1，否则是0（相同为0，不同为1）<br> 例3  5 ^ 4<br>5的二进制是  0000 0000 0000 0101<br>4的二进制是  0000 0000 0000 0100<br>则结果是        0000 0000 0000 0001 转为十进制是1<br>4、“非”、“位非”（~）也称为取反操作符<br>按位“非”操作符，属于一元操作符，只对一个操作数进行操作，（其他按位操作符是二元操作符）。按位“非”生成与输入位相反的值，——若输入0，则输出1，若输入1，则输出0。<br>例4  ~5<br>5的二进制是  0000 0000 0000 0101<br>则~5是           1111 1111 1111 1010  转为十进制是 -6。</p>
<h2 id="JAVA位运算符"><a href="#JAVA位运算符" class="headerlink" title="JAVA位运算符"></a>JAVA位运算符</h2><p><strong>移位操作符操作的运算对象也是二进制的“位”</strong></p>
<ul>
<li>移位操作符只可用来处理整数类型，左移位操作符（&lt;&lt;）能按照操作符右侧指定的位数将操作符左边的操作数向左移动（在低位补0）</li>
<li>有符号”右移位操作符（&gt;&gt;）则按照操作符右侧指定的位数将操作符左边的操作数向右移。“有符号”右移位操作符使用“符号扩展”；若符号位正，则在高位插入0；若符号位负。则在高位插入1。</li>
<li>java中增加了一种“无符号”右移位操作符（&gt;&gt;&gt;）,他使用“零扩展”；无论正负，都在高位插入0。这一操作符是C或C++中所没有的。<br>例6  5&lt;<2 5 等于20 5的二进制是 0000 0101 左移两位 0001 0100 例7>&gt;2 等于 1<br>5的二进制是   0000 0000 0000 0101<br>右移两位         0000 0000 0000 0001<br>例8  -5&gt;&gt;2 等于 -2   <strong>计算机中对于负数的计算都是通过补码。</strong><br>-5的二进制是   1111 1111 1111 1011<br>右移两位          1111 1111 1111 1110 转十进制，例5反着来，先-1，然后取反</2></li>
</ul>
<p>————————————————<br>版权声明：本文为CSDN博主「mxiaoyem」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/mxiaoyem/article/details/78569782" target="_blank" rel="noopener">https://blog.csdn.net/mxiaoyem/article/details/78569782</a></p>
<h3 id="JAVA-基础数据类型的转换"><a href="#JAVA-基础数据类型的转换" class="headerlink" title="JAVA 基础数据类型的转换"></a>JAVA 基础数据类型的转换</h3><p>java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。<br>自动转换按从低到高的顺序转换。<br>int —-&gt;  long —-&gt;float —-&gt; double</p>
<ul>
<li>int：<br>int 数据类型是32位、有符号的以二进制补码表示的<strong>整数</strong>；<br>最小值是 -2,147,483,648（-2^31）；<br>最大值是 2,147,483,647（2^31 - 1）；<br>一般地整型变量默认为 int 类型；<br>默认值是 0 ；<br>例子：int a = 100000, int b = -200000。</li>
<li>long：<br>long 数据类型是 64 位、有符号的以二进制补码表示的<strong>整数</strong>；<br>最小值是 -9,223,372,036,854,775,808（-2^63）；<br>最大值是 9,223,372,036,854,775,807（2^63 -1）；<br>这种类型主要使用在需要比较大整数的系统上；<br>默认值是 0L；<br>例子： long a = 100000L，Long b = -200000L。<br>“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。</li>
<li>float：<br>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；<br>float 在储存大型浮点数组的时候可节省内存空间；<br>默认值是 0.0f；<br>浮点数不能用来表示精确的值，如货币；<br>例子：float f1 = 234.5f。</li>
<li>double：<br>double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；<br>浮点数的默认类型为double类型；<br>double类型同样不能表示精确的值，如货币；<br>默认值是 0.0d；<br>例子：double d1 = 123.4。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/03/并发艺术编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen ZeTao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/weixin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddd `Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/03/并发艺术编程/" itemprop="url">并发艺术编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-03T23:37:25+08:00">
                2019-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/并发/" itemprop="url" rel="index">
                    <span itemprop="name">并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  12
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>启动一个java程序，操作系统就会创建一个进程，一个进程可以创建多个线程，这些线程都用友各自的计数器，堆栈和局部变量等属性，访问共享的内存变量。<br>JAVA程序天生就是多线程程序，执行main（）方法的是一个名为main的线程</strong></p>
<h2 id="为什么要多线程"><a href="#为什么要多线程" class="headerlink" title="为什么要多线程"></a>为什么要多线程</h2><ol>
<li>更多的处理器核心</li>
<li>更多的响应时间</li>
<li>更好的编程模型<h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2>通过一个整型变量priority控制优先级，thread.setPriority(priority)。</li>
</ol>
<ul>
<li>默认优先级 ： 5  范围从 1-10，优先级逐级增高</li>
<li>对于优先级的选择   对于频繁阻塞的任务（休眠 或 I/O操作） ，优先级应该高。对于偏重计算的任务（需要较多的CPU） , 优先级应该低，确保处理器不会被独占<br><strong>注意 ：线程优先级不能作为程序正确性的依赖，因为操作系统可以完成不用理会JAVA线程对于优先级的设定，对线程优先级的设置会被忽略。</strong><h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2>中断好比其他线程对该线程打了个招呼，其他线程通过调用该线程的interrupt()方法对其进行了中断操作。<h2 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h2>等待/通知机制，是指一个线程A调用了对象O的wait（）方法进入等待状态，而另一个线程B调用了对象O的notify（）或者notifyAll（）方法，线程A收到通知后从对象O的wait（）方法返回，进而执行后续操作。<br>notify（）：通知一个在对象上等待的线程，使其从wait()返回，前提是获得对象的锁<br>notifyAll（）：通知所有等待在该对象上的线程<br>wait（）：调用该方法的线程进入waiting状态，只有等待另外线程的通知或中断才会返回，需要注意，调用wait（）方法后，会返回对象的锁。</li>
</ul>
<ol>
<li>使用wait() , notify() 和 notify() 时需要先对调用对象加锁。</li>
<li>notify（）或notifyAll（）方法调用后，等待线程依旧不会从wait返回，需要调用notify（）或notifyAll（）的线程释放锁后，才有机会。</li>
<li>notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll（）方法则是将等待队列中所有线程全部移到同步队列中，被移动的线程状态由waiting变为blocked</li>
<li>从wait（）方法返回的前提是获得了调用对象的锁。<h2 id="volatile关键字-—最轻量级的同步机制"><a href="#volatile关键字-—最轻量级的同步机制" class="headerlink" title="volatile关键字 —最轻量级的同步机制"></a>volatile关键字 —最轻量级的同步机制</h2><h3 id="当一个变量被定义为volatile，两种特性"><a href="#当一个变量被定义为volatile，两种特性" class="headerlink" title="当一个变量被定义为volatile，两种特性"></a>当一个变量被定义为volatile，两种特性</h3></li>
<li>保证此变量对所有线程的可见性<br>“可见性” ：当一个线程修改此变量，其他线程是立即得知新值。但由于JAVA里面的运算并非原子操作，导致volatile变量在并发下也并不安全。（例如 a++）。具有可见性和原子性，但类似于volatile++这种复合操作不具有原子性。<br>通过字节码可以知道，其指令多了一个Lock前缀，使得本CPU的cache写入内存，该写入使得别的CPU无效其Cache，会重新从内存中读取，保证可见性。</li>
<li>禁止指令重排序优化（会干扰并发）<br>保证变量赋值操作的顺序与程序代码中的执行顺序一致。通过内存屏障，使重排序时后面的指令不能比屏障之前的先执行。意味着所有之前的操作都已经执行完成。<br>重排序：编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。<h2 id="Synchronized关键字，最基本的互斥同步手段"><a href="#Synchronized关键字，最基本的互斥同步手段" class="headerlink" title="Synchronized关键字，最基本的互斥同步手段"></a>Synchronized关键字，最基本的互斥同步手段</h2>Synchronize经过编译后，会在同步块前后分别形成两个monitorenter，monitorexit两个字节码指令。<br>工作原理  –&gt;monitorenter –&gt;尝试获取对象的锁 —&gt;失败，线程阻塞<br>—- &gt;成功，对象没被锁定，当前线程拥有对象的锁，锁的计数器加一<br>— &gt; monitorexit  —&gt;锁计数器减一 ，当计数器为0，锁就被释放 —&gt;唤醒被阻塞的线程<h2 id="锁释放-获取的内存语义与volatile写-读的内存语义是相同的"><a href="#锁释放-获取的内存语义与volatile写-读的内存语义是相同的" class="headerlink" title="锁释放 - 获取的内存语义与volatile写 - 读的内存语义是相同的"></a>锁释放 - 获取的内存语义与volatile写 - 读的内存语义是相同的</h2></li>
</ol>
<ul>
<li>线程A释放一个锁（写一个volatile变量），实质上线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。</li>
<li>线程B获取了一个锁（读一个volatile变量），实质上是线程B接收了之前某个线程发出的（在释放之前对共享变量所做修改的）消息。</li>
<li>线程A释放锁，随后线程B获取锁，这个过程实质上是线程A通过主内存向线程B发送消息。<h2 id="实现多线程的几种方法"><a href="#实现多线程的几种方法" class="headerlink" title="实现多线程的几种方法"></a>实现多线程的几种方法</h2></li>
</ul>
<ol>
<li><p>继承Thread类<br>通过JDK提供的Thread类，重写Thread类run方法即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;...&#125;</span><br><span class="line"><span class="comment">//启动 </span></span><br><span class="line"><span class="keyword">new</span> Thread1().start;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现Runnable接口  Runnable接口中仅定义一个run（）方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用内部类的方式<br>上面两种方式都需要再定义一个类，显得麻烦，通过匿名内部类实现，依然有两种</p>
</li>
</ol>
<ul>
<li><p>继承Thread a </p>
</li>
<li><p>实现 Runnable b</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;).start;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="4">
<li>带返回值的callable<br>实现callable接口</li>
<li>基于线程池的方式<h2 id="Thread-join"><a href="#Thread-join" class="headerlink" title="Thread.join()"></a>Thread.join()</h2>若一个线程A执行了thread.join()，含义是当前线程A等待Thread线程终止后才从join方法返回。<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2>锁的内部实现依赖于队列同步器<br>同步器底层通过一个<strong>双向队列</strong>，存放工作队列，当一个线程成功获取同步状态，其他线程将无法获取到同步状态，转而被构造成为节点并加入同步队列中。<h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2></li>
<li>自己可以再次获取自己的内部锁，任意线程在获取到锁之后能够再次获取该锁而不会被该锁所阻塞。Synchronize 和 基于Lock 实现的ReentrantLock都是可重入锁。</li>
<li>可重入锁 有两个特性</li>
</ol>
<ul>
<li>线程再次获取锁<br>锁需要识别获取锁的线程是否是当前占据锁的线程，如果是，可再成功获取</li>
<li><p>锁的最终释放<br>重复n次获取锁，在第n次释放锁后，其他线程才能获取到该锁</p>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>维护一对锁，一个读锁，一个写锁。通过分离读锁，写锁提高效率。<br>JAVA并发包提供读写锁的实现是 ReetrantReadWriteLock。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReetrantReadWriteLock rwl = <span class="keyword">new</span> ReetrantReadWriteLock();</span><br><span class="line">Lock r = rwl.readLock();  <span class="comment">// 读锁</span></span><br><span class="line">Lock w = rwl.writeLock(); <span class="comment">// 写锁</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>公平性选择 默认是非公平性</p>
</li>
<li>重进入锁</li>
<li>锁降级 <ul>
<li>先拿读锁（保证可见性）</li>
<li>放读锁，拿写锁，再拿读锁。<br>读写锁的实现是通过int变量维护多种状态，读写锁将变量切分，高16位表示读，低16位表示写。<h2 id="ReentrantLock-重点"><a href="#ReentrantLock-重点" class="headerlink" title="ReentrantLock   ***重点"></a>ReentrantLock   ***重点</h2></li>
</ul>
</li>
</ul>
<ol>
<li><p>通过调用Lock（）方法获取锁，unlock（）释放锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = new ReentrantLock();</span><br><span class="line">lock.lock()  ;  lock.unlock();</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现依赖于AQS框架，使用一个整型的volatile变量（state）来维持同步   <em>**</em>重点</p>
</li>
<li>公平锁的实现    <strong>*</strong>重点<h2 id="happens-before程序顺序规则是JMM核心的概念"><a href="#happens-before程序顺序规则是JMM核心的概念" class="headerlink" title="happens-before程序顺序规则是JMM核心的概念"></a>happens-before程序顺序规则是JMM核心的概念</h2>JMM通过happens-before来指定两个操作之间的执行顺序<br>定义： ①如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个可见，且第一个操作的执行顺序排在第二个之前 ———————-对程序员可见<br>②如果一个操作happens-before另一个操作，并不意味着必须按照happens-before关系指定的顺序执行，如果重排序之后的执行结果，与按happens-before顺序结果一致，那么这种重排序并不违法。 ————————对编译器和处理器的约束原则<h2 id="CAS-比较与替换是设计并发算法时用到的技术"><a href="#CAS-比较与替换是设计并发算法时用到的技术" class="headerlink" title="CAS 比较与替换是设计并发算法时用到的技术"></a>CAS 比较与替换是设计并发算法时用到的技术</h2>CAS是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyLock&#123;</span><br><span class="line">	private AtomicBoolean locked = nnew AtomicBoolean(false);</span><br><span class="line">	public boolean lock()&#123;</span><br><span class="line">		return locked.compareAndSet(false,true);</span><br><span class="line">	&#125;</span><br><span class="line">	//比较locked 和 false ，如果相等，则把它修改成true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="ConcurrentHashMap-是线程安全且高效的HashMap"><a href="#ConcurrentHashMap-是线程安全且高效的HashMap" class="headerlink" title="ConcurrentHashMap 是线程安全且高效的HashMap"></a>ConcurrentHashMap 是线程安全且高效的HashMap</h2><h3 id="ConcurrentHashMap的锁分段技术可有效提升并发访问率"><a href="#ConcurrentHashMap的锁分段技术可有效提升并发访问率" class="headerlink" title="ConcurrentHashMap的锁分段技术可有效提升并发访问率"></a>ConcurrentHashMap的锁分段技术可有效提升并发访问率</h3><p>  与HashTable容器相比，HashTable容器并发环境效率低下是所有访问HashTable的线程都必须访问同一把锁。<br>假如容器中有很多锁，每把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不存在竞争。这就是ConcurrentHashMap的锁分段技术。</p>
<h3 id="ConcurrentHashMap的结构"><a href="#ConcurrentHashMap的结构" class="headerlink" title="ConcurrentHashMap的结构"></a>ConcurrentHashMap的结构</h3><p>是有Segment数组结构 和 HashEntry 数组结构组成</p>
<ul>
<li>Segment是一种可重入锁，结构和HahMap类似，是一种数组和链表结构。</li>
<li>一个ConcurrentHashMap里包含一个Segment数组，扮演锁的角色。</li>
<li>每个HashEntry是一个链表结构的元素，一个Segment里包含一个HashEntry数组。</li>
<li>每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得与他对应的Segment锁。<h3 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h3>　  在定位Segment时，都会对元素的hashcode进行一次再散列。<br>在HashTable中，get方法是需要加锁的，但在ConcurrentHashMap中的get操作是不用加锁的。<br>原因： 在它的get方法中将要使用的共享变量都定义成volatile类型。能够在线程之间保持可见性，能够被多线程读，但只能被单线程写（有种情况可被多线程写，就是写入的值不依赖原值）。就像有多线程写， 也能get（）到最新的值。根据JMM的happens-before规则，对volatile的写入操作时优先于读操作的。这是用volatile替换锁的经典场景。<h3 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h3>put方法首先定位到Segment,然后在Segment里进入插入操作。<h3 id="ConcurrentHashMap的扩容"><a href="#ConcurrentHashMap的扩容" class="headerlink" title="ConcurrentHashMap的扩容"></a>ConcurrentHashMap的扩容</h3>首先会创建一个容量是原来容量两倍的数组，然后将原来的元素再散列插入到新数组中。为了高校，ConcurrentHashMap不会对整个容器进行扩容，而只对某个Segment进行扩容。<br>比HashMap更高校，HashMap是在插入后进行判断是否需要扩容， 但扩容后可能就不插入新元素。浪费了扩容的其他空间。<h2 id="阻塞队列（BlockingQueue）"><a href="#阻塞队列（BlockingQueue）" class="headerlink" title="阻塞队列（BlockingQueue）"></a>阻塞队列（BlockingQueue）</h2>是一个支持两个附加操作的队列，这两个附加的操作支持阻塞的插入和移除</li>
</ul>
<ol>
<li>支持阻塞的插入方法，意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。</li>
<li>支持阻塞的移除方法，当队列为空时，会阻塞移除元素的线程，等待队列不为空。<h2 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h2><h3 id="等待多线程完成的CountDownLatch"><a href="#等待多线程完成的CountDownLatch" class="headerlink" title="等待多线程完成的CountDownLatch"></a>等待多线程完成的CountDownLatch</h3>CountDownLatch允许一个或多个线程等待其他线程完成操作。<br>假如需求，解析一个Excel里多个sheet的数据，每个线程解析一个sheet，等所有的sheet都解析完，程序需要提示解析完成。<br>实现主线程等待所有线程完成sheet的解析，最简单是使用join（）方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread1.start();</span><br><span class="line">Thread2.start();</span><br><span class="line">Thread1.join();    <span class="comment">//主线程需等待join线程执行结束。</span></span><br><span class="line">THread2.join();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>CountDownLatch c = new CountDownLatch(2);<br>CountDownLatch接收一个int类型的参数作为计数器，如果想等待N个点完成，这里就传入N。<br>调用c.countDown()方法，N就会-1,c.await()方法会阻塞当前线程，直到N变成0；</p>
<h3 id="同步屏障-CyclicBarrier"><a href="#同步屏障-CyclicBarrier" class="headerlink" title="同步屏障 CyclicBarrier"></a>同步屏障 CyclicBarrier</h3><p>让一组线程到达一个屏障（同步点）时被阻塞，直至最后一个屏障到达才会开门，所有被屏障拦截的线程才会继续运行。<br>每个线程调用await（）告诉其已到屏障。<br>new CyclicBarrier（2）;     如果修改成3，但只有两个线程调用await（），主线程和子线程和永远等待，因为没有第3个线程执行await方法，即没有第3个线程到达屏障，所以之前到达屏障的线程都不会执行。</p>
<h3 id="CountDownLatch-和-CyclicBarrier的区别"><a href="#CountDownLatch-和-CyclicBarrier的区别" class="headerlink" title="CountDownLatch 和 CyclicBarrier的区别"></a>CountDownLatch 和 CyclicBarrier的区别</h3><p>CountDownLatch的计数器只能使用一次， CyclicBarrier的计数器可以使用reset（）重置。</p>
<h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h2><ol>
<li>线程池判断核心线程池里的线程是否都在执行任务（运行的线程少于corePoolSize，核心线程池还能添加工作线程），则创建新的工作线程来执行任务。（线程池创建线程时，会将线程封装成工作线程worker，Worker在执行任务后，还会循环获取工作队列里的任务来执行）<br>若工作线程都在执行任务，且核心线程池已满，则进入下个流程。<br>注意：创建新线程这一步需要获取全局锁，消耗资源。</li>
<li>线程池判断能否将任务加入工作队列，可以则加入工作队列FIFO，不可以则创建新线程。</li>
<li>如果创建新线程将使当前运行的线程超过MaxnumPoolSize（线程池大小），则交由饱和策略。<h3 id="线程池的创建-通过ThreadPoolExecutor来创建"><a href="#线程池的创建-通过ThreadPoolExecutor来创建" class="headerlink" title="线程池的创建  通过ThreadPoolExecutor来创建"></a>线程池的创建  通过ThreadPoolExecutor来创建</h3>new ThreadPoolExecutor（corePoolSize–线程池基本大小，MaxnumPoolSize—线程池最大数量，keepAliveTime，millsecond，runnablequeue—保存任务的阻塞队列，hanlder—饱和策略）<h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3></li>
<li>threadPool.execute (new Runnable(){…})<br>execute()方法用于提交不需要返回值的任务。（无法判断任务是否成功）</li>
<li>Future(Object)  future = threadPool.submit(new Runnable{})<br>submit()方法用于提交需要返回值的任务，会返回一个future对象，并且可以通过future的get（）方法来获取返回值，get（）会阻塞当前线程直到任务完成。<h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3>threadPool.shutdown();<br>原理：遍历工作线程，逐个调用线程的interrupt方法中断线程。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/02/排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen ZeTao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/weixin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddd `Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/02/排序/" itemprop="url">排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-02T11:01:41+08:00">
                2019-09-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  16
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h2><p>假设在排序前的序列中ri 领先于rj(即i&lt;j)。如果排序后ri仍领先于rj，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中rj领先ri,则称所用的排序方法是不稳定的。</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对顺序表做冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(SqList list)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>;i&lt;list.length;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = list.length-<span class="number">1</span>;j&gt;=i;j--)&#123;   <span class="comment">//注意j是从后往前递减	</span></span><br><span class="line">			<span class="keyword">if</span>(list[j-<span class="number">1</span>]&gt;list[j])&#123;		    <span class="comment">//若前者大于后者</span></span><br><span class="line">				swap(list,j-<span class="number">1</span>,j);			<span class="comment">//交换前者和后者的位置</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>较小的数字如同气泡般慢慢浮到上面，因此将此算法命名为冒泡排序。</p>
<h3 id="冒泡排序优化"><a href="#冒泡排序优化" class="headerlink" title="冒泡排序优化"></a>冒泡排序优化</h3><p>如果待排序的序列是{2,1,3,4,5,6,7,8}，也就是说，除了第一和第二的关键字需要交换外，别的已经是正常的顺序。当i=1时，交换了2和1，此时序列已将有序，但是算法仍然将i=2到8都执行了一遍，尽管没有交换数据，但是之后的大量比较大大的多余。<br>当i=2时，我们已经对9与8,8与7……3与2作了比较，没有任何数据交换，这就说明此序列已将有序，不需要再继续后面的循环判断工作。为了实现这个想法，需要改进代码，增加一个标记变量flag来实现算法的改进。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort2</span><span class="params">(SqList list)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	Boolean flag = <span class="keyword">false</span>;					<span class="comment">//flag用来做标记</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>;i&lt;list.length &amp;&amp; flag;i++)&#123;	<span class="comment">//若flag为false则退出循环</span></span><br><span class="line">		flag = <span class="keyword">false</span>;						<span class="comment">//初始flag为false</span></span><br><span class="line">		<span class="keyword">for</span> (j = list.length-<span class="number">1</span>;j&gt;=i;j--)&#123;   </span><br><span class="line">			<span class="keyword">if</span>(list[j-<span class="number">1</span>]&gt;list[j])&#123;		    </span><br><span class="line">				swap(list,j-<span class="number">1</span>,j);			</span><br><span class="line">				flag = <span class="keyword">true</span>;				<span class="comment">//若发生交换，flag=true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>最好的情况，排序的表本身就是有序的，根据最后改进的代码，可以推断出就是n-1次的比较，没有数据交换，时间复杂度是O(n)。<br>最坏的情况，即排序表时逆序的情况，此时需要比较1+2+3+4+5…+（n-1）= n(n-1)/2次，因此，总的时间复杂度为O(n2)。</p>
<h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p>选择排序法的初步思想，冒泡排序的思想是不断的交换，通过交换完成最终的排序，我们可以在排序时找到合适的关键字再做交换，并且只移动一次就完成相应关键字的排序定位工作。<br>简单选择排序法就是通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i个记录交换之。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对顺序表L作简单选择排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(SqList list)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,min;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;list.length;i++)&#123;</span><br><span class="line">		min = i;						<span class="comment">//将当前下标定义为最小值下标	</span></span><br><span class="line">		<span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;list.length;j++)&#123;	</span><br><span class="line">			<span class="keyword">if</span> (list[min] &gt; list[j])&#123;	<span class="comment">//从n-i+1中选出关键字最小的记录</span></span><br><span class="line">				min = j;				<span class="comment">//将此关键字的下标赋值给min</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (min != i)&#123;					<span class="comment">//若min不等于i,找到最小值，交换</span></span><br><span class="line">			swap(list,i,min);			<span class="comment">//交换list[i]和list[min]的值</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="简单选择排序复杂度分析"><a href="#简单选择排序复杂度分析" class="headerlink" title="简单选择排序复杂度分析"></a>简单选择排序复杂度分析</h3><p>从过程来看，它最大的特点就是交换移动数据次数相当少，这样也就节约了相应的时间。分析复杂度发现，无论最好最坏情况，其比较次数都是一样的多，第i趟排序需要进行n-i次关键字的比较，此时需要比较n-1+n-2+…=1 = n(n-1)/2次。因此，总的时间复杂度依然是O(n2).<br>应该说，尽管与冒泡排序同为O(n2),但简单选择排序的性能上还是要略优于冒泡排序。</p>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>直接插入排序的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的，记录数增1的有序表。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(SqList list)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="comment">//0的位置当成哨兵，假设list[1]已经排好位置，后面的牌其实就是插入到它的左侧还是右侧的问题</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">2</span>,j&lt;=list.length;i++)&#123;		</span><br><span class="line">		<span class="keyword">if</span> (list[i] &lt; list[i-<span class="number">1</span>])&#123;		<span class="comment">//升序，需将list[i]插入有序子表</span></span><br><span class="line">			list[<span class="number">0</span>] = list[i];			<span class="comment">//设置哨兵</span></span><br><span class="line">			<span class="keyword">for</span> (j=i-<span class="number">1</span>;list[j]&gt;list[<span class="number">0</span>];j--) &#123;</span><br><span class="line">				list[j+<span class="number">1</span>] = list[j];	<span class="comment">//记录后移				</span></span><br><span class="line">			&#125;</span><br><span class="line">			list[j+<span class="number">1</span>] = list[<span class="number">0</span>];		<span class="comment">//插入到正确位置</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="直接插入排序时间复杂度分析"><a href="#直接插入排序时间复杂度分析" class="headerlink" title="直接插入排序时间复杂度分析"></a>直接插入排序时间复杂度分析</h3><p>最好的情况，也就是要排序的表本身就是有序的，那么比较次数，其实就是代码第6行每个list[i]与list[i-1]的比较。时间复杂度为O(n)。<br>最坏的情况，2+3+4+…+n=(n+2)(n-1)/2,直接插入排序的时间复杂度为O(n2),同样的O(n2)时间复杂度，直接插入排序法比冒泡和简单选择排序的性能要好一些。</p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>在这之前排序算法的时间复杂度基本都是O(n2)，希尔排序算法是突破这个时间复杂度的第一批算法之一。在直接插入排序的基础上进行改进。<br>将原本有大量记录数的记录进行分组，分割成若干序列，采取跳跃分割的策略：将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对顺序表L做希尔排序</span></span><br><span class="line"><span class="comment">//将关键字较小的记录，不是一步一步地往前挪动，而是跳跃式地往前移，使得每完成一轮循环后，整个序列就朝着有序坚持地迈进了一步</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SheelSort</span><span class="params">(SqList list)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">int</span> increment = list.length();</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		increment = increment/<span class="number">3</span> +<span class="number">1</span>;				<span class="comment">//增量序列</span></span><br><span class="line">		<span class="keyword">for</span>(i=increment+<span class="number">1</span>;i&lt;=list.length();i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (list[i] &lt; list[i-increment])&#123;	<span class="comment">//跳跃判断</span></span><br><span class="line">				list[<span class="number">0</span>] = list[i]; 				<span class="comment">//暂存在list[0]</span></span><br><span class="line">				<span class="keyword">for</span> (j = i-increment;j&gt;<span class="number">0</span>&amp;&amp;list[<span class="number">0</span>]&lt;list[i];j-=increment)&#123;</span><br><span class="line">					list[j+increment] = list[j];	<span class="comment">//记录后移，查找插入位置</span></span><br><span class="line">				&#125;</span><br><span class="line">				list[j+increment] = list[<span class="number">0</span>];		<span class="comment">//插入</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">while</span>(increment&gt;<span class="number">1</span>);		<span class="comment">//当增量为1时，就停止循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="希尔排序复杂度分析"><a href="#希尔排序复杂度分析" class="headerlink" title="希尔排序复杂度分析"></a>希尔排序复杂度分析</h3><p>希尔排序的关键并不是随便分组后各自排序，而是将相隔某个“增量”的记录组成一个子序列，实现跳跃式的移动，使得排序的效率提高。<br>其时间复杂度为O(n3/2)，要好于直接排序的O(n2)，需要注意的是，增量序列的最后一个增量值必须等于1才行，另外记录是跳跃式的移动，希尔排序并不是一种稳定的排序算法。</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>前面讲到简单选择排序，他在待排序的n个记录中选择一个最小的记录需要比较n-1次，本来可以理解，查找第一个数据需要比较这么多次是正常的，可惜的是，这样的操作并没有把每一趟的比较结果保存下来，在后一趟的比较中，有许多比较在前一趟已经做过了，但由于前一趟排序时未保存这些比较结果，所以后一趟排序时又重复执行了这些比较操作，因而记录的比较次数较多，如果可以做到每次在选择到最小记录的同时，并根据比较结果对其他记录做出相应的调整，那排序的总体效率就会非常高。而堆排序就是对简单排序进行的一种改进。同时，他们发明了“堆”这样的数据结构。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是具有下列性质的完成二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆。<br>或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。<br>根结点一定是堆中所有结点最大（小）者。<br>如果按照层序遍历的方式给结点从1开始编号，则结点之间满足如下关系：<br>完全二叉树的特性，下标i与2i和2i+1是双亲子女关系。<br><strong>核心   大顶堆：ki &gt;= k2i , ki &gt;= k2i+1  小顶堆： ki &lt;=k2i , ki&lt;=k2i+1  ( 1&lt;= i &lt;= n/2 )</strong><br>堆排序利用此规则，完成排序。</p>
<h3 id="堆排序算法"><a href="#堆排序算法" class="headerlink" title="堆排序算法"></a>堆排序算法</h3><p>将要排序的数组，看成是按照层序遍历的完全二叉树。<br>堆排序就是利用堆（假设利用大顶堆）进行排序的方法。它的基本思想是，<strong>将待排序的序列构造成一个大顶堆，此时整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素的次大顶堆，如此反复执行，便能得到一个有序序列。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本函数调整list[s]的关键字，使list[s..m]成为一个大顶堆</span></span><br><span class="line"><span class="comment">//s 根节点 ，m 数组长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeadAdjust</span><span class="params">(SqlList list,<span class="keyword">int</span> s,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp,j;</span><br><span class="line">	temp = list[s];</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">2</span>*s;j&lt;=m;j*=<span class="number">2</span>)&#123;				<span class="comment">//沿关键字较大的孩子结点向下筛选</span></span><br><span class="line">		<span class="comment">//找出s结点下，最大的孩子结点。j为关键字中较大的记录的下标。</span></span><br><span class="line">		<span class="keyword">if</span> (j&lt;m &amp;&amp; list[j]&lt;list[j+<span class="number">1</span>])&#123;	</span><br><span class="line">			++j;		</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (temp &gt;= list[j])&#123;</span><br><span class="line">			<span class="keyword">break</span>;					<span class="comment">//根节点是最大的值，不需要改变位置</span></span><br><span class="line">		&#125;</span><br><span class="line">		list[s] =list[j];			<span class="comment">//将根节点与孩子结点数值交换，</span></span><br><span class="line">		<span class="comment">//s替换为j,进入下一次循环，看是否需要与下一个根节点互换</span></span><br><span class="line">		s=j;	</span><br><span class="line">	&#125;</span><br><span class="line">	list[s] = temp;				<span class="comment">//将孩子结点换成根节点的数值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>堆排序的核心算法已经有了，接下来就是对数组进行排序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(SqList list)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = list.length()/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)&#123;	   **		</span><br><span class="line">		HeadAdjust(list,i,list.length());	<span class="comment">//把list构建成一个大顶堆</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = list.length() ;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">		swap(list,<span class="number">1</span>,i);		<span class="comment">//将堆顶记录和当前子序列的最后一个记录交换。</span></span><br><span class="line">		HeadAdjust(list,<span class="number">1</span>,i-<span class="number">1</span>);  <span class="comment">//将list[1..i-1]重新调整为大顶堆</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假设list长度是9，从4往下递减，是因为都是有孩子的结点。<br>我们所谓的将待排序的序列构建成为一个大顶堆，其实就是从下往上，从右往左，将每个非终端结点（非叶结点）当成根节点，将其和其子树调整成大顶堆。</p>
<h3 id="堆排序的时间复杂度"><a href="#堆排序的时间复杂度" class="headerlink" title="堆排序的时间复杂度"></a>堆排序的时间复杂度</h3><p>堆排序的运行时间主要是消耗在初始构建堆和重建堆时的反复筛选上。<br>在构建堆的过程中，因为我们是完成二叉树从最下层最右边的非终端结点开始构建将它与其孩子进行和若有必要的互换，对于每个非终端结点来说，其实最多进行两次比较和互换操作，因此整个构建堆的时间复杂度为O(n)。<br>在正式排序时，第i次取堆顶记录重建堆需要用O(logi)的时间（完全二叉树的某个结点到根节点的距离为logi+1）,并且需要去n-1次堆顶记录，因此，重建堆的时间复杂度为O(nlogn)。<br>所以，总体来说，堆排序的时间复杂度为O(nlogn).</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>前面我们讲 了堆排序，因为它用到了完全二叉树，充分利用了完全二叉树的深度是log2n + 1的特性，所以效率比较高。不过堆结构的设计本身是比较复杂的，有没有更直接简单的方法利用完成二叉树来排序。当然有。归并排序法涉及到完全二叉树结构的排序算法。<br>归并排序就像是一颗倒置的完全二叉树</p>
<h3 id="归并排序算法"><a href="#归并排序算法" class="headerlink" title="归并排序算法"></a>归并排序算法</h3><p>归并排序就是利用归并的思想实现的排序方法。<strong>他的原理是假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到[n/2]个长度为2或1的有序子序列，再两两归并，…..,如此重复，直至得到一个长度为n的有序序列位置，这种排序方法称为2路归并排序。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对顺序表L作归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(Sqlist list)</span></span>&#123;</span><br><span class="line">	Msort(list,list,<span class="number">1</span>,list.length());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Msort</span><span class="params">(<span class="keyword">int</span> sr[],<span class="keyword">int</span> tr1[],<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="keyword">int</span> tr2[MAXSIZE+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span> (s == t)&#123;		<span class="comment">//当细分到一个记录填入tr2后，此时s和t相等，递归返回</span></span><br><span class="line">		tr1[s] = sr[s];</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		m = (s+t) /<span class="number">2</span>;  	 <span class="comment">//将sr[s..t]平分为sr[s..m]和sr[m+1..t]</span></span><br><span class="line">	<span class="number">10</span>	Msort(sr,tr2,s,m); <span class="comment">//递归将sr[s..m]归并为有序的tr2[s..m]</span></span><br><span class="line">		Msort(sr,tr2,m+<span class="number">1</span>,t); <span class="comment">//递归将sr[m+1..t]归并成有序的tr2[m+1..m]</span></span><br><span class="line">	<span class="number">12</span> 	Merge(tr2,tr1,s,m,t); <span class="comment">//将tr2[s..m]和tr2[m+1..t],归并到tr1[s..t]</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看第10行继续递归进去后，直到细分为一个记录填入tr2,此时s与t相等，递归返回，每次递归返回后都会执行当前递归函数的第12行，将tr2归并到tr1中，最终使得当前序列有序。<br>现在我们来看看Merge函数的代码是如果实现的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sr[] 待归并的数组，tr[]归并排序后的数组，i=1，m正中间值,n数组长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> sr[],<span class="keyword">int</span> tr[],<span class="keyword">int</span> i,<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j,k,l;	<span class="comment">//k记录tr数组坐标。 j记录sr数组右半段数组下标</span></span><br><span class="line">	<span class="keyword">for</span> (j = m+<span class="number">1</span>,k=i;i&lt;=m &amp;&amp; j&lt;=n;k++)&#123;  <span class="comment">//将sr中记录由小到大归并到tr</span></span><br><span class="line">		<span class="keyword">if</span> (sr[i] &lt;sr[j])&#123;</span><br><span class="line">			tr[k] = sr[i++];	<span class="comment">//将前后两段数组进行对比，牛逼</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			tr[k] = sr[j++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;   </span><br><span class="line">	<span class="keyword">if</span> (i &lt;=m)&#123;			<span class="comment">//将没有归并到tr的sr[1..m]复制到tr</span></span><br><span class="line">		<span class="keyword">for</span>(l=<span class="number">0</span>;l&lt;m-i;l++)&#123;</span><br><span class="line">			tr[k+<span class="number">1</span>]=sr[i+<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (j &lt;=n)&#123;			<span class="comment">//将没有归并到tr的sr[m+1..n]复制到tr</span></span><br><span class="line">		<span class="keyword">for</span>(l=<span class="number">0</span>;l&lt;n-j;l++)&#123;</span><br><span class="line">			tr[k+<span class="number">1</span>]=sr[i+<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="归并排序复杂度分析"><a href="#归并排序复杂度分析" class="headerlink" title="归并排序复杂度分析"></a>归并排序复杂度分析</h3><p>总的时间复杂度为O(nlogn),这是归并排序算法中最好，最坏，平均的时间性能。<br>归并排序Merge函数中有if（sr[i]&lt;sr[j]）,这就说明它需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法。</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>希尔排序相当于直接插入排序的升级，堆排序相当于简单选择排序的升级，它们同属于选择排序类，而快速排序其实就是最慢的冒泡排序的升级，都属于交换排序类，只不过它的实现，增大了记录的比较和移动的距离，将关键字较大的记录从前面直接移动到后面，关键字较小的记录从后面直接移动到前面，从而减小了总的比较次数和移动交换次数。</p>
<h3 id="快速排序算法"><a href="#快速排序算法" class="headerlink" title="快速排序算法"></a>快速排序算法</h3><p>快速排序的基本思想是:通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对顺序表L的子序列作快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(SqList list , <span class="keyword">int</span> low ,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot;</span><br><span class="line">	<span class="keyword">if</span> (low &lt; high)&#123;</span><br><span class="line">		pivot = Partition(L,low,high);  <span class="comment">//将list一分为二 算出枢轴值pivot</span></span><br><span class="line">		Qsort(list,low,pivot-<span class="number">1</span>);		<span class="comment">//对低子表递归排序</span></span><br><span class="line">		Qsort(list,pivot+<span class="number">1</span>,length);		<span class="comment">//对高子表递归排序</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(SqList list,<span class="keyword">int</span> low ,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivotkey;</span><br><span class="line">	pivotkey = list[low]; 		<span class="comment">//用子表的第一个记录做枢轴记录</span></span><br><span class="line">	<span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">	<span class="comment">//将第一个记录作为枢轴，则一定要从后往前扫</span></span><br><span class="line">		<span class="keyword">while</span> (low &lt;high &amp;&amp; list[high] &gt;=pivotkey)&#123;</span><br><span class="line">			high --;</span><br><span class="line">		&#125;			</span><br><span class="line">		swap(list,low,high);	<span class="comment">//将比枢轴小的记录交换到低端</span></span><br><span class="line">		<span class="keyword">while</span>(low &gt;high &amp;&amp; list[low] &lt;=pivotkey)&#123;</span><br><span class="line">			low ++;</span><br><span class="line">		&#125;</span><br><span class="line">		swap(list,low,high);	<span class="comment">//将比枢轴大的记录交换到高端</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> low;   <span class="comment">//返回枢轴所在位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="快速排序时间复杂度分析"><a href="#快速排序时间复杂度分析" class="headerlink" title="快速排序时间复杂度分析"></a>快速排序时间复杂度分析</h3><p>在最优的情况下，快速排序算法的时间复杂度为O(nlogn)。<br>最坏情况下，其时间复杂度是O(n*n)。<br>快速排序是一种不稳定的排序方法。<br>java对快速的实现  java.util.Arrays  —-&gt; static void sort(type[] a)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/21/递归/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen ZeTao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/weixin.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ddd `Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/21/递归/" itemprop="url">递归</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-21T15:15:23+08:00">
                2019-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://lylblog.cn/blog/4" target="_blank" rel="noopener">http://lylblog.cn/blog/4</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/weixin.jpg" alt="Chen ZeTao">
            
              <p class="site-author-name" itemprop="name">Chen ZeTao</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">41</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen ZeTao</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>



<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共75.4k字</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

  
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>
